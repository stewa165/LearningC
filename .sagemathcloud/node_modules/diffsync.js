// Generated by CoffeeScript 1.9.2
(function() {
  var CustomDiffSync, DiffSync, EventEmitter, FLAGS, MAX_SAVE_TIME_S, SIMULATE_LOSS, async, decompress_patch, defaults, diff_match_patch, dmp, hash_string, len, misc, required, test0,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  SIMULATE_LOSS = false;

  exports.MAX_SAVE_TIME_S = MAX_SAVE_TIME_S = 30;

  async = require('async');

  EventEmitter = require('events').EventEmitter;

  diff_match_patch = require('dmp').diff_match_patch;

  dmp = new diff_match_patch();

  dmp.Diff_Timeout = 0.2;

  dmp.Match_Threshold = 0.3;

  dmp.Patch_DeleteThreshold = 0.3;

  exports.dmp = dmp;

  misc = require('misc');

  defaults = misc.defaults, required = misc.required, hash_string = misc.hash_string, len = misc.len;

  DiffSync = (function(superClass) {
    extend(DiffSync, superClass);

    function DiffSync(opts) {
      this.status = bind(this.status, this);
      this.recv_edits = bind(this.recv_edits, this);
      this.push_edits = bind(this.push_edits, this);
      this.sync = bind(this.sync, this);
      this.connect = bind(this.connect, this);
      this._checksum = bind(this._checksum, this);
      this._apply_edits_to_live = bind(this._apply_edits_to_live, this);
      this._apply_edits = bind(this._apply_edits, this);
      this._compute_edits = bind(this._compute_edits, this);
      this._copy = bind(this._copy, this);
      this.snapshot = bind(this.snapshot, this);
      this.init = bind(this.init, this);
      this.init(opts);
    }

    DiffSync.prototype.init = function(opts) {
      opts = defaults(opts, {
        id: void 0,
        doc: required
      });
      if (opts.id == null) {
        this.id = misc.uuid();
      } else {
        this.id = opts.id;
      }
      this.live = opts.doc;
      this.shadow = this._copy(this.live);
      this.backup_shadow = this._copy(this.shadow);
      this.shadow_version = 0;
      this.backup_shadow_version = 0;
      this.last_version_received = -1;
      return this.edit_stack = [];
    };

    DiffSync.prototype.snapshot = function(cb) {
      return cb(false, this._copy(this.live));
    };

    DiffSync.prototype._copy = function(doc) {
      return doc;
    };

    DiffSync.prototype._compute_edits = function(version0, version1) {
      return dmp.patch_make(version0, version1);
    };

    DiffSync.prototype._apply_edits = function(edits, doc, cb) {
      return typeof cb === "function" ? cb(false, dmp.patch_apply(edits, doc)[0]) : void 0;
    };

    DiffSync.prototype._apply_edits_to_live = function(edits, cb) {
      if (typeof this._pre_apply_edits_to_live === "function") {
        this._pre_apply_edits_to_live();
      }
      return this._apply_edits(edits, this.live, (function(_this) {
        return function(err, result) {
          if (err) {
            if (typeof cb === "function") {
              cb(err);
            }
          } else {
            _this.live = result;
            return typeof cb === "function" ? cb() : void 0;
          }
        };
      })(this));
    };

    DiffSync.prototype._checksum = function(doc) {
      return doc.length;
    };

    DiffSync.prototype.connect = function(remote) {
      return this.remote = remote;
    };

    DiffSync.prototype.sync = function(cb) {
      return this.push_edits((function(_this) {
        return function(err) {
          if (err) {
            return cb(err);
          } else {
            return _this.remote.push_edits(cb);
          }
        };
      })(this));
    };

    DiffSync.prototype.push_edits = function(cb) {
      return this.snapshot((function(_this) {
        return function(err, snapshot) {
          var edits;
          if (err) {
            if (typeof cb === "function") {
              cb(err);
            }
            return;
          }
          if (snapshot == null) {
            if (typeof cb === "function") {
              cb("snapshot computed in push_edits is undefined");
            }
            return;
          }
          edits = {
            edits: _this._compute_edits(_this.shadow, snapshot)
          };
          if (edits.edits.length > 0) {
            edits.shadow_version = _this.shadow_version;
            edits.shadow_checksum = _this._checksum(_this.shadow);
            _this.edit_stack.push(edits);
            _this.shadow = snapshot;
            _this.shadow_version += 1;
          }
          if (SIMULATE_LOSS && Math.random() < .5) {
            console.log("Simulating loss!");
            if (typeof cb === "function") {
              cb(true);
            }
            return;
          }
          if (_this.remote != null) {
            return _this.remote.recv_edits(_this.edit_stack, _this.last_version_received, cb);
          } else {
            return typeof cb === "function" ? cb() : void 0;
          }
        };
      })(this));
    };

    DiffSync.prototype.recv_edits = function(edit_stack, last_version_ack, cb) {
      var edits, i, j, process_edit, tasks;
      if (SIMULATE_LOSS && Math.random() < .5) {
        console.log("Simulating loss!");
        if (typeof cb === "function") {
          cb(true);
        }
        return;
      }
      this.edit_stack = (function() {
        var l, len1, ref, results;
        ref = this.edit_stack;
        results = [];
        for (l = 0, len1 = ref.length; l < len1; l++) {
          edits = ref[l];
          if (edits.shadow_version > last_version_ack) {
            results.push(edits);
          }
        }
        return results;
      }).call(this);
      if (edit_stack.length === 0) {
        if (typeof cb === "function") {
          cb();
        }
        return;
      }
      if (edit_stack[0].shadow_version !== this.shadow_version && edit_stack[0].shadow_version === this.backup_shadow_version) {
        this.shadow = this._copy(this.backup_shadow);
        this.shadow_version = this.backup_shadow_version;
        this.edit_stack = [];
      }
      this.backup_shadow = this._copy(this.shadow);
      this.backup_shadow_version = this.shadow_version;
      i = 0;
      process_edit = (function(_this) {
        return function(cb) {
          edits = edit_stack[i];
          i += 1;
          if (edits.shadow_version === _this.shadow_version) {
            if (edits.shadow_checksum !== _this._checksum(_this.shadow)) {
              cb("reset -- checksum mismatch (" + edits.shadow_checksum + " != " + (_this._checksum(_this.shadow)) + ")");
              return;
            }
            return _this._apply_edits(edits.edits, _this.shadow, function(err, result) {
              if (err) {
                return cb(err);
              } else {
                _this.last_version_received = edits.shadow_version;
                _this.shadow = result;
                _this.shadow_version += 1;
                return _this._apply_edits_to_live(edits.edits, cb);
              }
            });
          } else {
            if (edits.shadow_version < _this.shadow_version) {
              return cb();
            } else if (edits.shadow_version > _this.shadow_version) {
              cb("reset -- shadow version from the future " + edits.shadow_version + " > " + _this.shadow_version);
            }
          }
        };
      })(this);
      tasks = (function() {
        var l, ref, results;
        results = [];
        for (j = l = 0, ref = edit_stack.length; 0 <= ref ? l < ref : l > ref; j = 0 <= ref ? ++l : --l) {
          results.push(process_edit);
        }
        return results;
      })();
      return async.series(tasks, function(err) {
        return typeof cb === "function" ? cb(err) : void 0;
      });
    };

    DiffSync.prototype.status = function() {
      return {
        'id': this.id,
        'live': this.live,
        'shadow': this.shadow,
        'shadow_version': this.shadow_version,
        'edit_stack': this.edit_stack
      };
    };

    return DiffSync;

  })(EventEmitter);

  CustomDiffSync = (function(superClass) {
    extend(CustomDiffSync, superClass);

    function CustomDiffSync(opts) {
      this._checksum = bind(this._checksum, this);
      this._apply_edits_to_live = bind(this._apply_edits_to_live, this);
      this._apply_edits = bind(this._apply_edits, this);
      this._compute_edits = bind(this._compute_edits, this);
      this._copy = bind(this._copy, this);
      opts = defaults(opts, {
        id: void 0,
        doc: required,
        copy: required,
        diff: required,
        patch: required,
        checksum: required,
        patch_in_place: void 0
      });
      this.opts = opts;
      this.init({
        id: opts.id,
        doc: opts.doc
      });
      this._patch = opts.patch;
      this._patch_in_place = opts.patch_in_place;
      this._checksum = opts.checksum;
    }

    CustomDiffSync.prototype._copy = function(doc) {
      return this.opts.copy(doc);
    };

    CustomDiffSync.prototype._compute_edits = function(version0, version1) {
      return this.opts.diff(version0, version1);
    };

    CustomDiffSync.prototype._apply_edits = function(edits, doc, cb) {
      return typeof cb === "function" ? cb(false, this.opts.patch(edits, doc)) : void 0;
    };

    CustomDiffSync.prototype._apply_edits_to_live = function(edits, cb) {
      if (typeof this._pre_apply_edits_to_live === "function") {
        this._pre_apply_edits_to_live();
      }
      if (this.opts.patch_in_place != null) {
        this.opts.patch_in_place(edits, this.live);
        return typeof cb === "function" ? cb() : void 0;
      } else {
        return this._apply_edits(edits, this.live, (function(_this) {
          return function(err, result) {
            if (err) {
              if (typeof cb === "function") {
                cb(err);
              }
            } else {
              _this.live = result;
              return typeof cb === "function" ? cb() : void 0;
            }
          };
        })(this));
      }
    };

    CustomDiffSync.prototype._checksum = function(doc) {
      return this.opts.checksum(doc);
    };

    return CustomDiffSync;

  })(DiffSync);

  exports.CustomDiffSync = CustomDiffSync;

  test0 = function(client, server, DocClass, Doc_equal, Doc_str) {
    var go, pusher, status;
    if (DocClass != null) {
      client.live = new DocClass("sage");
      server.live = new DocClass("my\nsage");
    } else {
      client.live = "sage";
      server.live = "my\nsage";
    }
    if (Doc_equal == null) {
      Doc_equal = function(s, t) {
        return s === t;
      };
    }
    if (Doc_str == null) {
      Doc_str = function(s) {
        return s;
      };
    }
    status = function() {
      console.log("------------------------");
      console.log("'" + (Doc_str(client.live)) + "'");
      return console.log("'" + (Doc_str(server.live)) + "'");
    };
    pusher = void 0;
    go = function() {
      if (pusher == null) {
        console.log("SWITCH client/server");
        if (Math.random() < .5) {
          pusher = 'client';
        } else {
          pusher = 'server';
        }
      }
      if (pusher === 'client') {
        return client.sync(function(err) {
          if (!err) {
            pusher = void 0;
          }
          if (err.slice(0, 5) === 'reset') {
            throw err;
          }
        });
      } else {
        return server.push_edits(function(err) {
          if (!err) {
            pusher = void 0;
          }
          if (err.slice(0, 5) === 'reset') {
            throw err;
          }
        });
      }
    };
    go();
    if (DocClass != null) {
      client.live = new DocClass("bar more stuffklajsdf lasdjf lasdj flasdjf lasjdfljas dfaklsdjflkasjd flajsdflkjasdklfj\n" + misc.uuid());
      server.live = new DocClass("bar lkajsdfllkjasdfl jasdlfj alsdkfjasdfjlkasdjflasjdfkljasdf\n" + misc.uuid());
    } else {
      client.live += "more stuffklajsdf lasdjf lasdj flasdjf lasjdfljas dfaklsdjflkasjd flajsdflkjasdklfj\n" + misc.uuid();
      server.live = 'bar\n' + server.live + "lkajsdfllkjasdfl jasdlfj alsdkfjas'dfjlkasdjflasjdfkljasdf\n" + misc.uuid();
    }
    status();
    while (!Doc_equal(client.live, server.live)) {
      status();
      go();
    }
    return status();
  };

  exports.test1 = function() {
    var client, server;
    client = new DiffSync({
      doc: "sage",
      id: "client"
    });
    server = new DiffSync({
      doc: "sage",
      id: "server"
    });
    client.connect(server);
    server.connect(client);
    return test0(client, server);
  };

  exports.test2 = function(n) {
    var i, l, ref, results;
    results = [];
    for (i = l = 0, ref = n; 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {
      results.push(exports.test1());
    }
    return results;
  };

  exports.test3 = function() {
    var client, server;
    client = new DiffSync({
      doc: "cat",
      id: "client"
    });
    server = new DiffSync({
      doc: "cat",
      id: "server"
    });
    client.connect(server);
    server.connect(client);
    client.live = "cats";
    server.live = "my\ncat";
    return client.sync((function(_this) {
      return function() {
        console.log(misc.to_json(client.status()));
        return console.log(misc.to_json(server.status()));
      };
    })(this));
  };

  exports.test4 = function(n) {
    var DS, checksum, client, copy, diff, i, l, patch, ref, results, server;
    if (n == null) {
      n = 1;
    }
    copy = function(s) {
      return s;
    };
    diff = function(v0, v1) {
      return dmp.patch_make(v0, v1);
    };
    patch = function(d, doc) {
      return dmp.patch_apply(d, doc)[0];
    };
    checksum = function(s) {
      return s.length + 3;
    };
    DS = function(id, doc) {
      return new CustomDiffSync({
        id: id,
        doc: doc,
        copy: copy,
        diff: diff,
        patch: patch,
        checksum: checksum
      });
    };
    results = [];
    for (i = l = 0, ref = n; 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {
      client = DS("client", "cat");
      server = DS("server", "cat");
      client.connect(server);
      server.connect(client);
      client.live = "cats";
      server.live = "my\ncat";
      client.sync((function(_this) {
        return function() {
          console.log(misc.to_json(client.status()));
          return console.log(misc.to_json(server.status()));
        };
      })(this));
      results.push(test0(client, server));
    }
    return results;
  };

  exports.test5 = function(n) {
    var DS, Doc, checksum, client, copy, diff, i, l, patch, patch_in_place, ref, results, server;
    if (n == null) {
      n = 1;
    }
    Doc = (function() {
      function Doc(doc1) {
        this.doc = doc1;
        if (this.doc.doc != null) {
          console.log("tried to make Doc(Doc)");
          traceback();
        }
        if (this.doc === '[object Object]') {
          console.log("tried to make Doc from obvious mistake");
          traceback();
        }
        if (this.doc == null) {
          console.log("tried to make Doc with undefined doc");
          traceback();
        }
        if (!(typeof this.doc === 'string')) {
          console.log("tried to make Doc from non-string '" + (misc.to_json(this.doc)) + "'");
          traceback();
        }
      }

      return Doc;

    })();
    copy = function(s) {
      return new Doc(s.doc);
    };
    diff = function(v0, v1) {
      return dmp.patch_make(v0.doc, v1.doc);
    };
    patch = function(d, doc) {
      return new Doc(dmp.patch_apply(d, doc.doc)[0]);
    };
    checksum = function(s) {
      return s.doc.length + 3;
    };
    patch_in_place = function(d, s) {
      return s.doc = dmp.patch_apply(d, s.doc)[0];
    };
    DS = function(id, doc) {
      return new CustomDiffSync({
        id: id,
        doc: doc,
        copy: copy,
        diff: diff,
        patch: patch,
        patch_in_place: patch_in_place,
        checksum: checksum
      });
    };
    results = [];
    for (i = l = 0, ref = n; 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {
      client = DS("client", new Doc("cat"));
      server = DS("server", new Doc("cat"));
      client.connect(server);
      server.connect(client);
      client.live = new Doc("cats");
      server.live = new Doc("my\nbat");
      client.sync((function(_this) {
        return function() {
          console.log(misc.to_json(client.status()));
          return console.log(misc.to_json(server.status()));
        };
      })(this));
      results.push(test0(client, server, Doc, (function(s, t) {
        return s.doc === t.doc;
      }), (function(s) {
        return s.doc;
      })));
    }
    return results;
  };

  exports.test6 = function(n) {
    var DS, Doc, checksum, client, copy, diff, i, l, patch, patch_in_place, ref, results, server, status;
    if (n == null) {
      n = 1;
    }
    Doc = (function() {
      function Doc(doc1) {
        this.doc = doc1;
        if (!(typeof this.doc === 'string')) {
          console.log("tried to make Doc from non-string '" + (misc.to_json(this.doc)) + "'");
          traceback();
        }
      }

      return Doc;

    })();
    copy = function(s) {
      return new Doc(s.doc);
    };
    diff = function(v0, v1) {
      var a, diffs;
      a = dmp.diff_linesToChars_(v0.doc, v1.doc);
      diffs = dmp.diff_main(a.chars1, a.chars2, false);
      dmp.diff_charsToLines_(diffs, a.lineArray);
      return dmp.patch_make(diffs);
    };
    patch = function(d, doc) {
      return new Doc(dmp.patch_apply(d, doc.doc)[0]);
    };
    checksum = function(s) {
      return s.doc.length + 3;
    };
    patch_in_place = function(d, s) {
      return s.doc = dmp.patch_apply(d, s.doc)[0];
    };
    DS = function(id, doc) {
      return new CustomDiffSync({
        id: id,
        doc: doc,
        copy: copy,
        diff: diff,
        patch: patch,
        patch_in_place: patch_in_place,
        checksum: checksum
      });
    };
    results = [];
    for (i = l = 0, ref = n; 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {
      client = DS("client", new Doc("cat"));
      server = DS("server", new Doc("cat"));
      status = function() {
        console.log(client.live.doc);
        console.log("-----");
        console.log(server.live.doc);
        return console.log("================");
      };
      client.connect(server);
      server.connect(client);
      status();
      client.live = new Doc("cat\nwilliam\nb\nstein\n");
      server.live = new Doc("cats\nstein\na\nb\nwilliam\n");
      results.push(client.sync((function(_this) {
        return function() {
          return status();
        };
      })(this)));
    }
    return results;
  };

  exports.test7 = function(n) {
    var DS, Doc, checksum, client, copy, dedup, diff, i, l, patch, patch_in_place, ref, results, server, status;
    if (n == null) {
      n = 1;
    }
    dedup = function(s) {
      var l, len1, line, lines_so_far, v, w;
      v = s.split('\n');
      lines_so_far = {};
      w = [];
      for (l = 0, len1 = v.length; l < len1; l++) {
        line = v[l];
        if (lines_so_far[line] == null) {
          w.push(line);
          lines_so_far[line] = true;
        }
      }
      return w.join('\n');
    };
    Doc = (function() {
      function Doc(doc1, dedup_doc) {
        this.doc = doc1;
        if (!(typeof this.doc === 'string')) {
          console.log("tried to make Doc from non-string '" + (misc.to_json(this.doc)) + "'");
          traceback();
        }
        if ((dedup_doc != null) && dedup_doc) {
          this.doc = dedup(this.doc);
        }
      }

      return Doc;

    })();
    copy = function(s) {
      return new Doc(s.doc, true);
    };
    diff = function(v0, v1) {
      var a, diffs;
      a = dmp.diff_linesToChars_(v0.doc, v1.doc);
      diffs = dmp.diff_main(a.chars1, a.chars2, false);
      dmp.diff_charsToLines_(diffs, a.lineArray);
      return dmp.patch_make(diffs);
    };
    patch = function(d, doc) {
      return new Doc(dmp.patch_apply(d, doc.doc)[0], true);
    };
    checksum = function(s) {
      return s.doc.length + 3;
    };
    patch_in_place = function(d, s) {
      return s.doc = dedup(dmp.patch_apply(d, s.doc)[0]);
    };
    DS = function(id, doc) {
      return new CustomDiffSync({
        id: id,
        doc: doc,
        copy: copy,
        diff: diff,
        patch: patch,
        patch_in_place: patch_in_place,
        checksum: checksum
      });
    };
    results = [];
    for (i = l = 0, ref = n; 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {
      client = DS("client", new Doc("cat"));
      server = DS("server", new Doc("cat"));
      status = function() {
        console.log(client.live.doc);
        console.log("-----");
        console.log(server.live.doc);
        return console.log("================");
      };
      client.connect(server);
      server.connect(client);
      status();
      client.live = new Doc("laskdjf\ncat\ncat\nwilliam\nb\nstein\n");
      server.live = new Doc("1290384\ncat\ncats\nstein\na\nb\nwilliam\n");
      results.push(client.sync((function(_this) {
        return function() {
          return status();
        };
      })(this)));
    }
    return results;
  };

  exports.DiffSync = DiffSync;

  exports.MARKERS = {
    cell: "\uFE20",
    output: "\uFE21"
  };

  exports.FLAGS = FLAGS = {
    execute: "x",
    waiting: "w",
    running: "r",
    interrupt: "c",
    this_session: "s",
    hide_input: "i",
    hide_output: "o",
    auto: "a"
  };

  exports.ACTION_FLAGS = [FLAGS.execute, FLAGS.running, FLAGS.waiting, FLAGS.interrupt, FLAGS.this_session];

  exports.uuids_of_linked_files = function(doc) {
    var i, j, l, len1, line, m, mesg, ref, ref1, uuid, uuids;
    uuids = [];
    i = 0;
    while (true) {
      i = doc.indexOf(exports.MARKERS.output, i);
      if (i === -1) {
        return uuids;
      }
      j = doc.indexOf('\n', i);
      if (j === -1) {
        j = doc.length;
      }
      line = doc.slice(i, j);
      ref = line.split(exports.MARKERS.output).slice(1);
      for (l = 0, len1 = ref.length; l < len1; l++) {
        m = ref[l];
        if (m.slice(0, 8) === '{"file":') {
          mesg = JSON.parse(m);
          uuid = (ref1 = mesg.file) != null ? ref1.uuid : void 0;
          if (uuid != null) {
            uuids.push(uuid);
          }
        }
      }
      i = j;
    }
  };


  /*
  Synchronized document-oriented database, based on differential synchronization.
  
  NOTE: The API is sort of like <http://hood.ie/#docs>, though I found that *after* I wrote this.
  The main difference is my syncdb doesn't use a database, instead using a file, and also it
  doesn't use localStorage.  HN discussion: <https://news.ycombinator.com/item?id=7767765>
   */


  /*
  For now _doc -- in the constructor of SynchronizedDB
  has a different API than DiffSync objects above.
  The wrapper object below allows you to use a DiffSync
  object with this API.
  
      _doc._presync -- if set, is called before syncing
      _doc.on 'sync' -- event emitted on successful sync
      _doc.live() -- returns current live string
      _doc.live('new value') -- set current live string
      _doc.sync(cb) -- cause sync of _doc
      _doc.save(cb) -- cause save of _doc to persistent storage
      _doc.readonly -- true if and only if doc is readonly
   */

  exports.SynchronizedDB_DiffSyncWrapper = (function(superClass) {
    extend(SynchronizedDB_DiffSyncWrapper, superClass);

    function SynchronizedDB_DiffSyncWrapper(doc1) {
      this.doc = doc1;
      this.save = bind(this.save, this);
      this.live = bind(this.live, this);
      this.sync = bind(this.sync, this);
      this.doc.on('sync', (function(_this) {
        return function() {
          return _this.emit('sync');
        };
      })(this));
    }

    SynchronizedDB_DiffSyncWrapper.prototype.sync = function(cb) {
      if (typeof this._presync === "function") {
        this._presync();
      }
      return this.doc.sync(cb);
    };

    SynchronizedDB_DiffSyncWrapper.prototype.live = function(value) {
      if (value == null) {
        return this.doc.live;
      } else {
        return this.doc.live = value;
      }
    };

    SynchronizedDB_DiffSyncWrapper.prototype.save = function(cb) {
      return this.doc.save(cb);
    };

    return SynchronizedDB_DiffSyncWrapper;

  })(EventEmitter);

  exports.SynchronizedDB = (function(superClass) {
    extend(SynchronizedDB, superClass);

    function SynchronizedDB(_doc, to_json, from_json, max_len) {
      this._doc = _doc;
      this.to_json = to_json;
      this.from_json = from_json;
      this.max_len = max_len;
      this.ensure_uuid_primary_key = bind(this.ensure_uuid_primary_key, this);
      this.ensure_objects = bind(this.ensure_objects, this);
      this.delete_one = bind(this.delete_one, this);
      this["delete"] = bind(this["delete"], this);
      this.select_one = bind(this.select_one, this);
      this.select = bind(this.select, this);
      this.update = bind(this.update, this);
      this.sync = bind(this.sync, this);
      this.save = bind(this.save, this);
      this._set_doc_from_data = bind(this._set_doc_from_data, this);
      this._set_data_from_doc = bind(this._set_data_from_doc, this);
      this.destroy = bind(this.destroy, this);
      this._on_sync = bind(this._on_sync, this);
      if (this.to_json == null) {
        this.to_json = misc.to_json;
      }
      if (this.from_json == null) {
        this.from_json = misc.from_json;
      }
      this.readonly = this._doc.readonly;
      this._data = {};
      this._set_data_from_doc();
      this._doc._presync = (function(_this) {
        return function() {
          var ref;
          return _this._live_before_sync = (ref = _this._doc) != null ? ref.live() : void 0;
        };
      })(this);
      this._doc.on('sync', this._on_sync);
    }

    SynchronizedDB.prototype._on_sync = function() {
      if (this._doc == null) {
        return;
      }
      this.emit('sync');
      if (!this._set_data_from_doc() && (this._live_before_sync != null)) {
        this._doc.live(this._live_before_sync);
        this._set_data_from_doc();
        this.emit('presync');
        return this._doc.sync();
      }
    };

    SynchronizedDB.prototype.destroy = function() {
      var ref, ref1;
      if ((ref = this._doc) != null) {
        ref.removeListener('sync', this._on_sync);
      }
      if ((ref1 = this._doc) != null) {
        ref1.disconnect_from_session();
      }
      delete this._doc;
      delete this._data;
      return this.removeAllListeners();
    };

    SynchronizedDB.prototype._set_data_from_doc = function() {
      var changes, data, e, h, hashes, i, is_valid, l, len1, ref, ref1, v, x;
      if (this._doc == null) {
        return;
      }
      i = 0;
      hashes = {};
      changes = [];
      is_valid = true;
      ref = this._doc.live().split('\n');
      for (l = 0, len1 = ref.length; l < len1; l++) {
        x = ref[l];
        if (x.length > 0) {
          h = hash_string(x);
          hashes[h] = true;
          if (this._data[h] == null) {
            try {
              data = this.from_json(x);
            } catch (_error) {
              e = _error;
              data = {
                'corrupt': x
              };
              is_valid = false;
            }
            this._data[h] = {
              data: data,
              line: i
            };
            changes.push({
              insert: misc.deep_copy(data)
            });
          }
        }
        i += 1;
      }
      ref1 = this._data;
      for (h in ref1) {
        v = ref1[h];
        if (hashes[h] == null) {
          changes.push({
            remove: v.data
          });
          delete this._data[h];
        }
      }
      if (changes.length > 0) {
        this.emit("change", changes);
      }
      return is_valid;
    };

    SynchronizedDB.prototype._set_doc_from_data = function(hash) {
      var d, l, len1, line, m, new_hash, ref, v, x, z;
      if (this._doc == null) {
        return;
      }
      if ((hash != null) && (this._data[hash] != null)) {
        d = this._data[hash];
        v = this._doc.live().split('\n');
        v[d.line] = this.to_json(d.data);
        new_hash = hash_string(v[d.line]);
        if (new_hash !== hash) {
          this._data[new_hash] = d;
          delete this._data[hash];
        }
      } else {
        m = [];
        ref = this._data;
        for (hash in ref) {
          x = ref[hash];
          m[x.line] = {
            hash: hash,
            x: x
          };
        }
        m = (function() {
          var l, len1, results;
          results = [];
          for (l = 0, len1 = m.length; l < len1; l++) {
            x = m[l];
            if (x != null) {
              results.push(x);
            }
          }
          return results;
        })();
        line = 0;
        v = [];
        for (l = 0, len1 = m.length; l < len1; l++) {
          z = m[l];
          if (z == null) {
            continue;
          }
          z.x.line = line;
          v.push(this.to_json(z.x.data));
          line += 1;
        }
      }
      this._doc.live(v.join('\n'));
      this.emit('presync');
      return this._doc.sync();
    };

    SynchronizedDB.prototype.save = function(cb) {
      var f;
      if (this._doc == null) {
        if (typeof cb === "function") {
          cb("@_doc not defined");
        }
        return;
      }
      f = (function(_this) {
        return function(cb) {
          return _this.sync(function(err) {
            if (err) {
              return cb(err);
            } else {
              if (_this._doc == null) {
                return typeof cb === "function" ? cb("@_doc not defined") : void 0;
              } else {
                return _this._doc.save(cb);
              }
            }
          });
        };
      })(this);
      return misc.retry_until_success({
        f: f,
        start_delay: 3000,
        max_delay: 5000,
        factor: 1.3,
        max_time: 1000 * MAX_SAVE_TIME_S,
        cb: cb
      });
    };

    SynchronizedDB.prototype.sync = function(cb) {
      if (this._doc == null) {
        return typeof cb === "function" ? cb("@_doc not defined") : void 0;
      } else {
        return this._doc.sync(cb);
      }
    };

    SynchronizedDB.prototype.update = function(opts) {
      var before, changed, changes, cur_len, hash, i, j, k, match, new_len, new_obj, ref, set, v, val, where, x;
      opts = defaults(opts, {
        set: required,
        where: required
      });
      if (this._doc == null) {
        return;
      }
      set = opts.set;
      where = opts.where;
      i = 0;
      ref = this._data;
      for (hash in ref) {
        val = ref[hash];
        match = true;
        x = val.data;
        for (k in where) {
          v = where[k];
          if (x[k] !== v) {
            match = false;
            break;
          }
        }
        if (match) {
          changed = false;
          before = misc.deep_copy(x);
          for (k in set) {
            v = set[k];
            if (!changed && misc.to_json(x[k]) !== misc.to_json(v)) {
              changes = [
                {
                  remove: before
                }
              ];
              changed = true;
            }
            x[k] = v;
          }
          if (changed) {
            if (this.max_len != null) {
              cur_len = this._doc.live().length;
              new_len = misc.to_json(x).length - misc.to_json(before).length + cur_len;
              if (new_len > this.max_len) {
                this._data[hash].data = before;
                throw {
                  error: "max_len",
                  new_len: new_len,
                  cur_len: cur_len,
                  max_len: this.max_len
                };
              }
            }
            changes.push({
              insert: misc.deep_copy(x)
            });
            this.emit("change", changes);
            this._set_doc_from_data(hash);
          }
          return;
        }
        i += 1;
      }
      new_obj = {};
      for (k in set) {
        v = set[k];
        new_obj[k] = v;
      }
      for (k in where) {
        v = where[k];
        new_obj[k] = v;
      }
      j = this.to_json(new_obj);
      if (this.max_len != null) {
        cur_len = this._doc.live().length;
        new_len = j.length + 1 + this._doc.live().length;
        if (new_len > this.max_len) {
          throw {
            error: "max_len",
            new_len: new_len,
            cur_len: cur_len,
            max_len: this.max_len
          };
        }
      }
      hash = hash_string(j);
      this._data[hash] = {
        data: new_obj,
        line: len(this._data)
      };
      this._set_doc_from_data(hash);
      return this.emit("change", [
        {
          insert: misc.deep_copy(new_obj)
        }
      ]);
    };

    SynchronizedDB.prototype.select = function(opts) {
      var hash, k, match, ref, result, v, val, where, x;
      if (opts == null) {
        opts = {};
      }
      where = defaults(opts, {
        where: {}
      }).where;
      if (this._data == null) {
        return [];
      }
      result = [];
      ref = this._data;
      for (hash in ref) {
        val = ref[hash];
        x = val.data;
        match = true;
        for (k in where) {
          v = where[k];
          if (x[k] !== v) {
            match = false;
            break;
          }
        }
        if (match) {
          result.push(x);
        }
      }
      return misc.deep_copy(result);
    };

    SynchronizedDB.prototype.select_one = function(opts) {
      var hash, k, match, ref, v, val, where, x;
      if (opts == null) {
        opts = {};
      }
      where = defaults(opts, {
        where: {}
      }).where;
      if (this._data == null) {
        return;
      }
      ref = this._data;
      for (hash in ref) {
        val = ref[hash];
        x = val.data;
        match = true;
        for (k in where) {
          v = where[k];
          if (x[k] !== v) {
            match = false;
            break;
          }
        }
        if (match) {
          return misc.deep_copy(x);
        }
      }
    };

    SynchronizedDB.prototype["delete"] = function(opts) {
      var changes, hash, i, k, match, one, ref, ref1, result, v, val, where, x;
      ref = defaults(opts, {
        where: required,
        one: false
      }), where = ref.where, one = ref.one;
      if (this._data == null) {
        return 0;
      }
      result = [];
      i = 0;
      changes = [];
      ref1 = this._data;
      for (hash in ref1) {
        val = ref1[hash];
        x = val.data;
        match = true;
        for (k in where) {
          v = where[k];
          if (x[k] !== v) {
            match = false;
            break;
          }
        }
        if (match) {
          i += 1;
          changes.push({
            remove: x
          });
          delete this._data[hash];
          if (one) {
            break;
          }
        }
      }
      if (i > 0) {
        this._set_doc_from_data();
        this.emit("change", changes);
      }
      return i;
    };

    SynchronizedDB.prototype.delete_one = function(opts) {
      opts.one = true;
      return this["delete"](opts);
    };

    SynchronizedDB.prototype.ensure_objects = function(key) {
      var changes, h, h2, ref, v, x;
      if (this._data == null) {
        return;
      }
      changes = {};
      ref = this._data;
      for (h in ref) {
        v = ref[h];
        if (typeof v.data !== 'object') {
          x = v.data;
          v.data = {};
          v.data[key] = x;
          h2 = hash_string(this.to_json(v.data));
          delete this._data[h];
          changes[h2] = v;
        }
      }
      if (misc.len(changes) > 0) {
        for (h in changes) {
          v = changes[h];
          this._data[h] = v;
        }
        return this._set_doc_from_data();
      }
    };

    SynchronizedDB.prototype.ensure_uuid_primary_key = function(key) {
      var changes, h, h2, ref, uuids, v, w;
      if (this._data == null) {
        return;
      }
      uuids = {};
      changes = {};
      ref = this._data;
      for (h in ref) {
        v = ref[h];
        if ((v.data[key] == null) || uuids[v.data[key]]) {
          v.data[key] = misc.uuid();
          h2 = hash_string(this.to_json(v.data));
          delete this._data[h];
          changes[h2] = v;
        }
        uuids[v.data[key]] = true;
      }
      if (misc.len(changes) > 0) {
        w = [];
        for (h in changes) {
          v = changes[h];
          w.push({
            remove: this._data[h]
          });
          w.push({
            insert: v
          });
        }
        this.emit("change", w);
        for (h in changes) {
          v = changes[h];
          this._data[h] = v;
        }
        return this._set_doc_from_data();
      }
    };

    return SynchronizedDB;

  })(EventEmitter);

  exports.compress_patch = function(patch) {
    var l, len1, p, results;
    results = [];
    for (l = 0, len1 = patch.length; l < len1; l++) {
      p = patch[l];
      results.push([p.diffs, p.start1, p.start2, p.length1, p.length2]);
    }
    return results;
  };

  exports.decompress_patch = decompress_patch = function(patch) {
    var l, len1, p, results;
    results = [];
    for (l = 0, len1 = patch.length; l < len1; l++) {
      p = patch[l];
      results.push({
        diffs: p[0],
        start1: p[1],
        start2: p[2],
        length1: p[3],
        length2: p[4]
      });
    }
    return results;
  };

  exports.decompress_patch_compat = function(patch) {
    var ref;
    if (((ref = patch[0]) != null ? ref.diffs : void 0) != null) {
      return patch;
    } else {
      return decompress_patch(patch);
    }
  };

  exports.invert_patch_in_place = function(patch) {
    var i, j, l, o, ref, ref1, temp;
    if (patch.length === 0) {
      return patch;
    }
    for (i = l = 0, ref = patch.length - 1; 0 <= ref ? l <= ref : l >= ref; i = 0 <= ref ? ++l : --l) {
      temp = patch[i].length1;
      patch[i].length1 = patch[i].length2;
      patch[i].length2 = temp;
      for (j = o = 0, ref1 = patch[i].diffs.length - 1; 0 <= ref1 ? o <= ref1 : o >= ref1; j = 0 <= ref1 ? ++o : --o) {
        patch[i].diffs[j][0] = -patch[i].diffs[j][0];
      }
    }
    return patch = patch.reverse();
  };

}).call(this);
