// Generated by CoffeeScript 1.9.2
(function() {
  var CONFPATH, CONSOLE_SERVER_MAX_STARTUP_TIME_S, CodeMirrorDiffSyncHub, CodeMirrorSession, CodeMirrorSessions, ConsoleSessions, DATA, DiffSyncFile_client, DiffSyncFile_server, INFO, MAX_FILE_SIZE, REVISION_TRACKING_SAVE_INTERVAL, SAGEMATHCLOUD_LOG_FILE, SAGEMATHCLOUD_LOG_THRESH, SAGE_SERVER_MAX_STARTUP_TIME_S, SageSessions, _get_sage_socket, _restarted_console_server, _restarted_sage_server, _restarting_console_server, _restarting_sage_server, _save_blob_callbacks, abspath, activity, async, check_file_size, child_process, codemirror_sessions, connect_to_session, console_sessions, daemon, defaults, diffsync, ensure_containing_directory_exists, expire_time, forget_port, from_json, fs, get_port, get_sage_socket, handle_mesg, handle_save_blob_message, init_confpath, init_info_json, json, jupyter_port, jupyter_port_queue, last_activity, log_truncate, message, misc, misc_node, net, plug, ports, print_sagews, print_to_pdf, process_kill, program, project_exec, raw_server_domain, read_file_from_project, receive_save_blob_message, ref, required, restart_console_server, restart_sage_server, revision_tracking_path, sage_sessions, secret_token, secret_token_filename, secret_token_length, server, session_info, start_log_truncate, start_raw_server, start_server, start_tcp_server, temp, terminate_session, to_json, uuid, winston, write_file_to_project,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  async = require('async');

  fs = require('fs');

  net = require('net');

  child_process = require('child_process');

  uuid = require('node-uuid');

  message = require('message');

  misc = require('misc');

  misc_node = require('misc_node');

  winston = require('winston');

  temp = require('temp');

  diffsync = require('diffsync');

  ref = require('misc'), to_json = ref.to_json, from_json = ref.from_json, defaults = ref.defaults, required = ref.required;

  json = function(out) {
    return misc.trunc(misc.to_json(out), 512);
  };

  ensure_containing_directory_exists = misc_node.ensure_containing_directory_exists, abspath = misc_node.abspath;

  expire_time = function(ttl) {
    if (ttl) {
      return new Date((new Date() - 0) + ttl * 1000);
    }
  };

  MAX_FILE_SIZE = 10000000;

  check_file_size = function(size) {
    var e;
    if ((size != null) && size > MAX_FILE_SIZE) {
      e = "Attempt to open large file of size " + (Math.round(size / 1000000)) + "MB; the maximum allowed size is " + (Math.round(MAX_FILE_SIZE / 1000000)) + "MB. Use vim, emacs, or pico from a terminal instead.";
      winston.debug(e);
      return e;
    }
  };


  /*
   * Revision tracking misc.
   */

  REVISION_TRACKING_SAVE_INTERVAL = 45000;

  revision_tracking_path = function(path) {
    var s;
    s = misc.path_split(path);
    return s.head + "/." + s.tail + ".sage-history";
  };


  /* not used (so commented out), but could be useful...
  patch_from_trivial = (s) ->
      return [
          diffs   : [ [ 1, s ] ],
          start1  : 0,
          start2  : 0,
          length1 : 0,
          length2 : s.length }
      ]
   */

  DATA = process.env['SAGEMATHCLOUD'] + '/data';

  CONFPATH = exports.CONFPATH = abspath(DATA);

  secret_token_filename = exports.secret_token_filename = CONFPATH + "/secret_token";

  secret_token = void 0;

  secret_token_length = 128;

  init_confpath = function() {
    return async.series([
      function(cb) {
        return fs.exists(secret_token_filename, function(exists) {
          if (exists) {
            winston.debug("read '" + secret_token_filename + "'");
            return fs.readFile(secret_token_filename, function(err, buf) {
              secret_token = buf.toString();
              return cb();
            });
          } else {
            winston.debug("create '" + secret_token_filename + "'");
            return require('crypto').randomBytes(secret_token_length, function(ex, buf) {
              secret_token = buf.toString('base64');
              return fs.writeFile(secret_token_filename, secret_token, cb);
            });
          }
        });
      }, function(cb) {
        return fs.chmod(secret_token_filename, 0x180, cb);
      }
    ]);
  };

  INFO = void 0;

  init_info_json = function() {
    var base_url, filename, host, port, project_id, ref1, username, v;
    winston.debug("writing info.json");
    filename = process.env['SAGEMATHCLOUD'] + "/info.json";
    v = process.env['HOME'].split('/');
    project_id = v[v.length - 1];
    username = project_id.replace(/-/g, '');
    host = (ref1 = require('os').networkInterfaces().eth0) != null ? ref1[0].address : void 0;
    base_url = '';
    port = 22;
    INFO = {
      project_id: project_id,
      location: {
        host: host,
        username: username,
        port: port,
        path: '.'
      },
      base_url: base_url
    };
    return fs.writeFileSync(filename, misc.to_json(INFO));
  };

  ports = {};

  get_port = function(type, cb) {
    if (ports[type] != null) {
      return cb(false, ports[type]);
    } else {
      return fs.readFile(abspath(DATA + "/" + type + "_server.port"), function(err, content) {
        var e;
        if (err) {
          return cb(err);
        } else {
          try {
            ports[type] = parseInt(content);
            return cb(false, ports[type]);
          } catch (_error) {
            e = _error;
            return cb(type + "_server port file corrupted");
          }
        }
      });
    }
  };

  forget_port = function(type) {
    if (ports[type] != null) {
      return delete ports[type];
    }
  };

  CONSOLE_SERVER_MAX_STARTUP_TIME_S = 10;

  _restarting_console_server = false;

  _restarted_console_server = 0;

  restart_console_server = function(cb) {
    var dbg, err, port, port_file, t;
    dbg = function(m) {
      return winston.debug("restart_console_server: " + (misc.to_json(m)));
    };
    if (_restarting_console_server) {
      dbg("hit lock -- already restarting console server");
      cb("already restarting console server");
      return;
    }
    t = new Date() - _restarted_console_server;
    if (t <= CONSOLE_SERVER_MAX_STARTUP_TIME_S * 1000) {
      err = "restarted console server " + t + "ms ago -- still waiting for it to start";
      dbg(err);
      cb(err);
      return;
    }
    _restarting_console_server = true;
    dbg("restarting the daemon");
    dbg("killing all existing console sockets");
    console_sessions.terminate_all_sessions();
    port_file = abspath(DATA + "/console_server.port");
    port = void 0;
    return async.series([
      function(cb) {
        dbg("remove port_file=" + port_file);
        return fs.unlink(port_file, function(err) {
          return cb();
        });
      }, function(cb) {
        dbg("restart console server");
        return misc_node.execute_code({
          command: "console_server restart",
          timeout: 10,
          ulimit_timeout: false,
          err_on_exit: true,
          bash: true,
          cb: cb
        });
      }, function(cb) {
        var f;
        dbg("wait a little to see if " + port_file + " appears, and if so read it and return port");
        f = function(cb) {
          return fs.exists(port_file, function(exists) {
            if (!exists) {
              return cb(true);
            } else {
              return fs.readFile(port_file, function(err, data) {
                var error;
                if (err) {
                  return cb(err);
                } else {
                  try {
                    port = parseInt(data.toString());
                    return cb();
                  } catch (_error) {
                    error = _error;
                    return cb('reading port corrupt');
                  }
                }
              });
            }
          });
        };
        return misc.retry_until_success({
          f: f,
          max_time: 7000,
          cb: cb
        });
      }
    ], (function(_this) {
      return function(err) {
        _restarting_console_server = false;
        _restarted_console_server = new Date();
        dbg("finished trying to restart console_server");
        if (err) {
          dbg("ERROR: " + err);
        }
        return cb(err, port);
      };
    })(this));
  };

  ConsoleSessions = (function() {
    function ConsoleSessions() {
      this.info = bind(this.info, this);
      this._new_session = bind(this._new_session, this);
      this._get_console_server_socket = bind(this._get_console_server_socket, this);
      this.get_session = bind(this.get_session, this);
      this.connect = bind(this.connect, this);
      this.terminate_all_sessions = bind(this.terminate_all_sessions, this);
      this.terminate_session = bind(this.terminate_session, this);
      this.session_exists = bind(this.session_exists, this);
      this._sessions = {};
      this._get_session_cbs = {};
    }

    ConsoleSessions.prototype.session_exists = function(session_uuid) {
      return this._sessions[session_uuid] != null;
    };

    ConsoleSessions.prototype.terminate_session = function(session_uuid, cb) {
      var session;
      session = this._sessions[session_uuid];
      if (session == null) {
        return typeof cb === "function" ? cb() : void 0;
      } else {
        winston.debug("terminate console session '" + session_uuid + "'");
        if (session.status === 'running') {
          session.socket.end();
          session.status = 'done';
          return typeof cb === "function" ? cb() : void 0;
        } else {
          return typeof cb === "function" ? cb() : void 0;
        }
      }
    };

    ConsoleSessions.prototype.terminate_all_sessions = function() {
      var e, ref1, results, session, session_uuid;
      ref1 = this._sessions[session_uuid];
      results = [];
      for (session_uuid in ref1) {
        session = ref1[session_uuid];
        try {
          results.push(session.socket.end());
        } catch (_error) {
          e = _error;
          results.push(session.status = 'done');
        }
      }
      return results;
    };

    ConsoleSessions.prototype.connect = function(client_socket, mesg, cb) {
      if (mesg.session_uuid == null) {
        mesg.session_uuid = misc.uuid();
      }
      client_socket.on('end', (function(_this) {
        return function() {
          return winston.debug("a console session client socket ended -- session_uuid=" + mesg.session_uuid);
        };
      })(this));
      return this.get_session(mesg, (function(_this) {
        return function(err, session) {
          if (err) {
            client_socket.write_mesg('json', message.error({
              id: mesg.id,
              error: err
            }));
            return typeof cb === "function" ? cb(err) : void 0;
          } else {
            client_socket.write_mesg('json', {
              desc: session.desc,
              history: session.history.toString()
            });
            plug(client_socket, session.socket, 20000);
            session.clients.push(client_socket);
            return typeof cb === "function" ? cb() : void 0;
          }
        };
      })(this));
    };

    ConsoleSessions.prototype.get_session = function(mesg, cb) {
      var history, port, session;
      winston.debug("get_session: console session " + mesg.session_uuid);
      session = this._sessions[mesg.session_uuid];
      if ((session != null) && session.status === 'running') {
        winston.debug("console session: done -- it's already there and working");
        cb(void 0, session);
        return;
      }
      if (this._get_session_cbs[mesg.session_uuid] == null) {
        winston.debug("console session not yet created -- put on stack");
        this._get_session_cbs[mesg.session_uuid] = [cb];
      } else {
        winston.debug("console session already being created -- just push cb onto stack and return");
        this._get_session_cbs[mesg.session_uuid].push(cb);
        return;
      }
      port = void 0;
      history = void 0;
      return async.series([
        (function(_this) {
          return function(cb) {
            if (session != null) {
              history = session.history;
            }
            winston.debug("console session does not exist or is not running, so we make a new session");
            session = void 0;
            return get_port('console', function(err, _port) {
              if (err) {
                return cb();
              } else {
                port = _port;
                winston.debug("got console server port = " + port);
                return cb();
              }
            });
          };
        })(this), (function(_this) {
          return function(cb) {
            if (port != null) {
              return cb();
            } else {
              winston.debug("couldn't determine console server port; probably console server not running -- try restarting it");
              return restart_console_server(function(err, _port) {
                if (err) {
                  return cb(err);
                } else {
                  port = _port;
                  winston.debug("restarted console server, then got port = " + port);
                  return cb();
                }
              });
            }
          };
        })(this), (function(_this) {
          return function(cb) {
            return _this._new_session(mesg, port, function(err, _session) {
              if (err) {
                return cb(err);
              } else {
                session = _session;
                if (history != null) {
                  session.history = history;
                }
                return cb();
              }
            });
          };
        })(this)
      ], (function(_this) {
        return function(err) {
          var l, len, ref1;
          ref1 = _this._get_session_cbs[mesg.session_uuid];
          for (l = 0, len = ref1.length; l < len; l++) {
            cb = ref1[l];
            cb(err, session);
          }
          return delete _this._get_session_cbs[mesg.session_uuid];
        };
      })(this));
    };

    ConsoleSessions.prototype._get_console_server_socket = function(port, cb) {
      var f, socket;
      socket = void 0;
      f = (function(_this) {
        return function(cb) {
          return misc_node.connect_to_locked_socket({
            port: port,
            token: secret_token,
            cb: function(err, _socket) {
              if (err) {
                return cb(err);
              } else {
                socket = _socket;
                return cb();
              }
            }
          });
        };
      })(this);
      return async.series([
        (function(_this) {
          return function(cb) {
            return misc.retry_until_success({
              f: f,
              max_time: 5000,
              cb: function(err) {
                return cb();
              }
            });
          };
        })(this), (function(_this) {
          return function(cb) {
            if (socket != null) {
              cb();
              return;
            }
            forget_port('console');
            return restart_console_server(function(err, _port) {
              if (err) {
                return cb(err);
              } else {
                port = _port;
                return cb();
              }
            });
          };
        })(this), (function(_this) {
          return function(cb) {
            if (socket != null) {
              cb();
              return;
            }
            return misc.retry_until_success({
              f: f,
              max_time: 5000,
              cb: cb
            });
          };
        })(this)
      ], (function(_this) {
        return function(err) {
          if (err) {
            return cb(err);
          } else {
            return cb(void 0, socket);
          }
        };
      })(this));
    };

    ConsoleSessions.prototype._new_session = function(mesg, port, cb) {
      winston.debug("_new_session: defined by " + (json(mesg)));
      return this._get_console_server_socket(port, (function(_this) {
        return function(err, console_socket) {
          if (err) {
            cb("_new_session: console server failed to connect -- " + err);
            return;
          }
          misc_node.enable_mesg(console_socket);
          console_socket.write_mesg('json', mesg);
          console_socket.once('mesg', function(type, desc) {
            var history, session;
            if (typeof history === "undefined" || history === null) {
              history = new Buffer(0);
            }
            misc_node.disable_mesg(console_socket);
            session = {
              socket: console_socket,
              desc: desc,
              status: 'running',
              clients: [],
              history: '',
              session_uuid: mesg.session_uuid,
              project_id: mesg.project_id
            };
            session.amount_of_data = 0;
            session.last_data = misc.mswalltime();
            console_socket.on('data', function(data) {
              var n, tm;
              tm = misc.mswalltime();
              if (tm - session.last_data >= 2) {
                session.amount_of_data = 0;
              }
              session.last_data = tm;
              if (session.amount_of_data > 50000) {
                data = '[...]';
              }
              session.history += data;
              session.amount_of_data += data.length;
              n = session.history.length;
              if (n > 200000) {
                return session.history = session.history.slice(session.history.length - 100000);
              }
            });
            _this._sessions[mesg.session_uuid] = session;
            return cb(void 0, session);
          });
          return console_socket.on('end', function() {
            var client, l, len, ref1, results, session;
            winston.debug("console session " + mesg.session_uuid + " ended");
            session = _this._sessions[mesg.session_uuid];
            if (session != null) {
              session.status = 'done';
              ref1 = session.clients;
              results = [];
              for (l = 0, len = ref1.length; l < len; l++) {
                client = ref1[l];
                results.push(client.end());
              }
              return results;
            }
          });
        };
      })(this));
    };

    ConsoleSessions.prototype.info = function(project_id) {
      var id, obj, ref1, session;
      obj = {};
      ref1 = this._sessions;
      for (id in ref1) {
        session = ref1[id];
        if (session.project_id === project_id) {
          obj[id] = {
            desc: session.desc,
            status: session.status,
            history_length: session.history.length
          };
        }
      }
      return obj;
    };

    return ConsoleSessions;

  })();

  console_sessions = new ConsoleSessions();

  SAGE_SERVER_MAX_STARTUP_TIME_S = 30;

  _restarting_sage_server = false;

  _restarted_sage_server = 0;

  exports.restart_sage_server = restart_sage_server = function(cb) {
    var dbg, err, t;
    dbg = function(m) {
      return winston.debug("restart_sage_server: " + (misc.to_json(m)));
    };
    if (_restarting_sage_server) {
      dbg("hit lock");
      cb("already restarting sage server");
      return;
    }
    t = new Date() - _restarted_sage_server;
    if (t <= SAGE_SERVER_MAX_STARTUP_TIME_S * 1000) {
      err = "restarted sage server " + t + "ms ago -- still waiting for it to start";
      dbg(err);
      cb(err);
      return;
    }
    _restarting_sage_server = true;
    dbg("restarting the daemon");
    return misc_node.execute_code({
      command: "sage_server stop; sage_server start",
      timeout: 30,
      ulimit_timeout: false,
      err_on_exit: true,
      bash: true,
      cb: function(err) {
        _restarting_sage_server = false;
        _restarted_sage_server = new Date();
        return cb(err);
      }
    });
  };

  get_sage_socket = function(cb) {
    var socket, try_to_connect;
    socket = void 0;
    try_to_connect = function(cb) {
      return _get_sage_socket(function(err, _socket) {
        if (!err) {
          socket = _socket;
          return cb();
        } else {
          return restart_sage_server(function(err) {
            return cb(true);
          });
        }
      });
    };
    return misc.retry_until_success({
      f: try_to_connect,
      start_delay: 2000,
      max_delay: 6000,
      factor: 1.5,
      max_time: SAGE_SERVER_MAX_STARTUP_TIME_S * 1000,
      log: function(m) {
        return winston.debug("get_sage_socket: " + m);
      },
      cb: function(err) {
        return cb(err, socket);
      }
    });
  };

  _get_sage_socket = function(cb) {
    var port, sage_socket;
    sage_socket = void 0;
    port = void 0;
    return async.series([
      (function(_this) {
        return function(cb) {
          winston.debug("get sage server port");
          return get_port('sage', function(err, _port) {
            if (err) {
              cb(err);
            } else {
              port = _port;
              return cb();
            }
          });
        };
      })(this), (function(_this) {
        return function(cb) {
          winston.debug("get and unlock socket");
          return misc_node.connect_to_locked_socket({
            port: port,
            token: secret_token,
            cb: function(err, _socket) {
              if (err) {
                forget_port('sage');
                winston.debug("unlock socket: _new_session: sage session denied connection: " + err);
                cb("_new_session: sage session denied connection: " + err);
                return;
              }
              sage_socket = _socket;
              winston.debug("Successfully unlocked a sage session connection.");
              return cb();
            }
          });
        };
      })(this), (function(_this) {
        return function(cb) {
          winston.debug("request sage session from server.");
          misc_node.enable_mesg(sage_socket);
          sage_socket.write_mesg('json', message.start_session({
            type: 'sage'
          }));
          winston.debug("Waiting to read one JSON message back, which will describe the session....");
          return sage_socket.once('mesg', function(type, desc) {
            winston.debug("Got message back from Sage server: " + (json(desc)));
            sage_socket.pid = desc.pid;
            return cb();
          });
        };
      })(this)
    ], function(err) {
      return cb(err, sage_socket);
    });
  };

  plug = function(s1, s2, max_burst) {
    var amount, last_data, last_tm, s1_data, s2_data;
    last_tm = misc.mswalltime();
    last_data = '';
    amount = 0;
    s1_data = function(data) {
      activity();
      if (!s2.writable) {
        return s1.removeListener('data', s1_data);
      } else {
        return s2.write(data);
      }
    };
    s2_data = function(data) {
      var e, tm, x;
      if (!s1.writable) {
        return s2.removeListener('data', s2_data);
      } else {
        if (max_burst != null) {
          tm = misc.mswalltime();
          if (tm - last_tm >= 20) {
            if (amount < 0) {
              try {
                x = last_data.slice(Math.max(0, last_data.length - Math.floor(max_burst / 4)));
              } catch (_error) {
                e = _error;
                x = '';
              }
              data = "]" + x + data;
            }
            amount = 0;
          }
          last_tm = tm;
          if (amount >= max_burst) {
            last_data = data;
            data = data.slice(0, Math.floor(max_burst / 4)) + "[...";
            amount = -1;
            setTimeout(((function(_this) {
              return function() {
                return s2_data('');
              };
            })(this)), 25);
          } else if (amount < 0) {
            last_data += data;
            setTimeout(((function(_this) {
              return function() {
                return s2_data('');
              };
            })(this)), 25);
          } else {
            amount += data.length;
          }
        }
        return s1.write(data);
      }
    };
    s1.on('data', s1_data);
    return s2.on('data', s2_data);
  };

  SageSessions = (function() {
    function SageSessions() {
      this.info = bind(this.info, this);
      this._new_session = bind(this._new_session, this);
      this.connect = bind(this.connect, this);
      this.get_session = bind(this.get_session, this);
      this.update_session_status = bind(this.update_session_status, this);
      this.terminate_session = bind(this.terminate_session, this);
      this.session_exists = bind(this.session_exists, this);
      this._sessions = {};
    }

    SageSessions.prototype.session_exists = function(session_uuid) {
      return this._sessions[session_uuid] != null;
    };

    SageSessions.prototype.terminate_session = function(session_uuid, cb) {
      var S;
      S = this._sessions[session_uuid];
      if (S == null) {
        return cb();
      } else {
        winston.debug("terminate sage session -- STUB!");
        return cb();
      }
    };

    SageSessions.prototype.update_session_status = function(session) {
      var e;
      try {
        return process.kill(session.desc.pid, 0);
      } catch (_error) {
        e = _error;
        return session.status = 'done';
      }
    };

    SageSessions.prototype.get_session = function(uuid) {
      var session;
      session = this._sessions[uuid];
      if (session != null) {
        this.update_session_status(session);
      }
      return session;
    };

    SageSessions.prototype.connect = function(client_socket, mesg) {
      var session;
      session = this.get_session(mesg.session_uuid);
      if ((session != null) && session.status === 'running') {
        winston.debug("sage sessions: connect to the running session with id " + mesg.session_uuid);
        client_socket.write_mesg('json', session.desc);
        plug(client_socket, session.socket);
        return session.clients.push(client_socket);
      } else {
        winston.debug("make a connection to a new sage session.");
        return get_port('sage', (function(_this) {
          return function(err, port) {
            winston.debug("Got sage server port = " + port);
            if (err) {
              winston.debug("can't determine sage server port; probably sage server not running");
              return client_socket.write_mesg('json', message.error({
                id: mesg.id,
                error: "problem determining port of sage server."
              }));
            } else {
              return _this._new_session(client_socket, mesg, port);
            }
          };
        })(this));
      }
    };

    SageSessions.prototype._new_session = function(client_socket, mesg, port, retries) {
      winston.debug("_new_session: creating new sage session (retries=" + retries + ")");
      return misc_node.connect_to_locked_socket({
        port: port,
        token: secret_token,
        cb: (function(_this) {
          return function(err, sage_socket) {
            var try_again;
            if (err) {
              winston.debug("_new_session: sage session denied connection: " + err);
              forget_port('sage');
              if ((retries == null) || retries <= 5) {
                if (retries == null) {
                  retries = 1;
                } else {
                  retries += 1;
                }
                try_again = function() {
                  return _this._new_session(client_socket, mesg, port, retries);
                };
                setTimeout(try_again, 1000);
              } else {
                client_socket.write_mesg('json', message.error({
                  id: mesg.id,
                  error: "local_hub -- Problem connecting to Sage server. -- " + err
                }));
              }
              return;
            } else {
              winston.debug("Successfully unlocked a sage session connection.");
            }
            winston.debug("Next, request a Sage session from sage_server.");
            misc_node.enable_mesg(sage_socket);
            sage_socket.write_mesg('json', message.start_session({
              type: 'sage'
            }));
            winston.debug("Waiting to read one JSON message back, which will describe the session.");
            sage_socket.once('mesg', function(type, desc) {
              winston.debug("Got message back from Sage server: " + (json(desc)));
              client_socket.write_mesg('json', desc);
              plug(client_socket, sage_socket);
              return _this._sessions[mesg.session_uuid] = {
                socket: sage_socket,
                desc: desc,
                status: 'running',
                clients: [client_socket],
                project_id: mesg.project_id
              };
            });
            return sage_socket.on('end', function() {
              var session;
              winston.debug("sage_socket: session " + mesg.session_uuid + " terminated.");
              session = _this._sessions[mesg.session_uuid];
              if (session != null) {
                winston.debug("sage_socket: setting status of session " + mesg.session_uuid + " to terminated.");
                return session.status = 'done';
              }
            });
          };
        })(this)
      });
    };

    SageSessions.prototype.info = function(project_id) {
      var id, obj, ref1, session;
      obj = {};
      ref1 = this._sessions;
      for (id in ref1) {
        session = ref1[id];
        if (session.project_id === project_id) {
          obj[id] = {
            desc: session.desc,
            status: session.status
          };
        }
      }
      return obj;
    };

    return SageSessions;

  })();

  sage_sessions = new SageSessions();

  DiffSyncFile_server = (function(superClass) {
    extend(DiffSyncFile_server, superClass);

    function DiffSyncFile_server(cm_session, cb) {
      var file, no_master, stats, stats_path;
      this.cm_session = cm_session;
      this.write_to_disk = bind(this.write_to_disk, this);
      this._apply_edits_to_live = bind(this._apply_edits_to_live, this);
      this.snapshot = bind(this.snapshot, this);
      this._stop_watching_file = bind(this._stop_watching_file, this);
      this._start_watching_file = bind(this._start_watching_file, this);
      this._watcher = bind(this._watcher, this);
      this.kill = bind(this.kill, this);
      this.path = this.cm_session.path;
      no_master = void 0;
      stats_path = void 0;
      stats = void 0;
      file = void 0;
      async.series([
        (function(_this) {
          return function(cb) {
            return fs.stat(_this.path, function(_no_master, _stats_path) {
              no_master = _no_master;
              stats_path = _stats_path;
              return cb();
            });
          };
        })(this), (function(_this) {
          return function(cb) {
            if (no_master) {
              file = _this.path;
              return misc_node.ensure_containing_directory_exists(_this.path, function(err) {
                if (err) {
                  return cb(err);
                } else {
                  return fs.open(file, 'w', function(err, fd) {
                    if (err) {
                      return cb(err);
                    } else {
                      return fs.close(fd, cb);
                    }
                  });
                }
              });
            } else {
              file = _this.path;
              stats = stats_path;
              return cb();
            }
          };
        })(this), (function(_this) {
          return function(cb) {
            var e;
            e = check_file_size(stats != null ? stats.size : void 0);
            if (e) {
              cb(e);
              return;
            }
            return fs.readFile(file, function(err, data) {
              if (err) {
                cb(err);
                return;
              }
              _this.init({
                doc: data.toString().replace(/\r/g, ''),
                id: "file_server"
              });
              _this._start_watching_file();
              return cb(err);
            });
          };
        })(this)
      ], (function(_this) {
        return function(err) {
          return cb(err, _this.live);
        };
      })(this));
    }

    DiffSyncFile_server.prototype.kill = function() {
      if (this._autosave != null) {
        clearInterval(this._autosave);
      }
      return fs.unwatchFile(this.path, this._watcher);
    };

    DiffSyncFile_server.prototype._watcher = function(event) {
      winston.debug("watch: file '" + this.path + "' modified.");
      if (!this._do_watch) {
        winston.debug("watch: skipping read because watching is off.");
        return;
      }
      this._stop_watching_file();
      return async.series([
        (function(_this) {
          return function(cb) {
            return fs.stat(_this.path, function(err, stats) {
              if (err) {
                return cb(err);
              } else {
                return cb(check_file_size(stats.size));
              }
            });
          };
        })(this), (function(_this) {
          return function(cb) {
            return fs.readFile(_this.path, function(err, data) {
              if (err) {
                return cb(err);
              } else {
                _this.live = data.toString().replace(/\r/g, '');
                return _this.cm_session.sync_filesystem(cb);
              }
            });
          };
        })(this)
      ], (function(_this) {
        return function(err) {
          if (err) {
            winston.debug("watch: file '" + _this.path + "' error -- " + err);
          }
          return _this._start_watching_file();
        };
      })(this));
    };

    DiffSyncFile_server.prototype._start_watching_file = function() {
      if (this._do_watch != null) {
        this._do_watch = true;
        return;
      }
      this._do_watch = true;
      winston.debug("watching " + this.path);
      return fs.watchFile(this.path, this._watcher);
    };

    DiffSyncFile_server.prototype._stop_watching_file = function() {
      return this._do_watch = false;
    };

    DiffSyncFile_server.prototype.snapshot = function(cb) {
      return cb(false, this.live);
    };

    DiffSyncFile_server.prototype._apply_edits_to_live = function(edits, cb) {
      if (edits.length === 0) {
        cb();
        return;
      }
      return this._apply_edits(edits, this.live, (function(_this) {
        return function(err, result) {
          if (err) {
            return cb(err);
          } else {
            if (result === _this.live) {
              return cb();
            } else {
              _this.live = result;
              return _this.write_to_disk(cb);
            }
          }
        };
      })(this));
    };

    DiffSyncFile_server.prototype.write_to_disk = function(cb) {
      this._stop_watching_file();
      return ensure_containing_directory_exists(this.path, (function(_this) {
        return function(err) {
          if (err) {
            if (typeof cb === "function") {
              cb(err);
            }
            return;
          }
          return fs.writeFile(_this.path, _this.live, function(err) {
            _this._start_watching_file();
            return typeof cb === "function" ? cb(err) : void 0;
          });
        };
      })(this));
    };

    return DiffSyncFile_server;

  })(diffsync.DiffSync);

  DiffSyncFile_client = (function(superClass) {
    extend(DiffSyncFile_client, superClass);

    function DiffSyncFile_client(server1) {
      this.server = server1;
      DiffSyncFile_client.__super__.constructor.call(this, {
        doc: this.server.live,
        id: "file_client"
      });
      this.connect(this.server);
      this.server.connect(this);
    }

    return DiffSyncFile_client;

  })(diffsync.DiffSync);

  CodeMirrorDiffSyncHub = (function() {
    function CodeMirrorDiffSyncHub(socket1, session_uuid1, client_id1) {
      this.socket = socket1;
      this.session_uuid = session_uuid1;
      this.client_id = client_id1;
      this.sync_ready = bind(this.sync_ready, this);
      this.recv_edits = bind(this.recv_edits, this);
      this.write_mesg = bind(this.write_mesg, this);
    }

    CodeMirrorDiffSyncHub.prototype.write_mesg = function(event, obj) {
      var mesg;
      if (obj == null) {
        obj = {};
      }
      obj.session_uuid = this.session_uuid;
      mesg = message['codemirror_' + event](obj);
      mesg.client_id = this.client_id;
      return this.socket.write_mesg('json', mesg);
    };

    CodeMirrorDiffSyncHub.prototype.recv_edits = function(edit_stack, last_version_ack, cb) {
      this.write_mesg('diffsync', {
        id: this.current_mesg_id,
        edit_stack: edit_stack,
        last_version_ack: last_version_ack
      });
      return typeof cb === "function" ? cb() : void 0;
    };

    CodeMirrorDiffSyncHub.prototype.sync_ready = function() {
      return this.write_mesg('diffsync_ready');
    };

    return CodeMirrorDiffSyncHub;

  })();

  CodeMirrorSession = (function() {
    function CodeMirrorSession(mesg, cb) {
      this.update_revision_tracking = bind(this.update_revision_tracking, this);
      this.revision_tracking = bind(this.revision_tracking, this);
      this.get_content = bind(this.get_content, this);
      this.read_from_disk = bind(this.read_from_disk, this);
      this.write_to_disk = bind(this.write_to_disk, this);
      this.remove_client = bind(this.remove_client, this);
      this.add_client = bind(this.add_client, this);
      this.sync_filesystem = bind(this.sync_filesystem, this);
      this.tell_clients_to_update = bind(this.tell_clients_to_update, this);
      this.client_diffsync = bind(this.client_diffsync, this);
      this.client_bcast = bind(this.client_bcast, this);
      this.set_content = bind(this.set_content, this);
      this.kill = bind(this.kill, this);
      this.sage_initialize_cell_for_execute = bind(this.sage_initialize_cell_for_execute, this);
      this.sage_remove_cell_flag = bind(this.sage_remove_cell_flag, this);
      this.sage_set_cell_flag = bind(this.sage_set_cell_flag, this);
      this.sage_set_cell_flagstring = bind(this.sage_set_cell_flagstring, this);
      this.sage_get_cell_flagstring = bind(this.sage_get_cell_flagstring, this);
      this.sage_find_cell_meta = bind(this.sage_find_cell_meta, this);
      this.sage_output_mesg = bind(this.sage_output_mesg, this);
      this.sage_update = bind(this.sage_update, this);
      this.send_signal_to_sage_session = bind(this.send_signal_to_sage_session, this);
      this.sage_introspect = bind(this.sage_introspect, this);
      this.sage_call = bind(this.sage_call, this);
      this.sage_raw_input = bind(this.sage_raw_input, this);
      this.sage_execute_code = bind(this.sage_execute_code, this);
      this.sage_execute_cell = bind(this.sage_execute_cell, this);
      this._set_content_and_sync = bind(this._set_content_and_sync, this);
      this.sage_socket = bind(this.sage_socket, this);
      this.path = mesg.path;
      this.session_uuid = mesg.session_uuid;
      this._sage_output_cb = {};
      this._sage_output_to_input_id = {};
      this.diffsync_clients = {};
      async.series([
        (function(_this) {
          return function(cb) {
            return fs.exists(_this.path, function(exists) {
              if (exists) {
                return cb();
              } else {
                return fs.open(_this.path, 'w', function(err, fd) {
                  if (err) {
                    return cb(err);
                  } else {
                    return fs.close(fd, cb);
                  }
                });
              }
            });
          };
        })(this), (function(_this) {
          return function(cb) {
            if (_this.path.indexOf('.snapshots/') !== -1) {
              _this.readonly = true;
              return cb();
            } else {
              return misc_node.is_file_readonly({
                path: _this.path,
                cb: function(err, readonly) {
                  _this.readonly = readonly;
                  return cb(err);
                }
              });
            }
          };
        })(this), (function(_this) {
          return function(cb) {
            if (!_this.readonly && misc.filename_extension_notilde(_this.path) === 'sagews') {
              _this.process_new_content = _this.sage_update;
              return _this.sage_socket(cb);
            } else {
              return cb();
            }
          };
        })(this), (function(_this) {
          return function(cb) {
            return _this.diffsync_fileserver = new DiffSyncFile_server(_this, function(err, content) {
              if (err) {
                cb(err);
                return;
              }
              _this.content = content;
              _this.diffsync_fileclient = new DiffSyncFile_client(_this.diffsync_fileserver);
              _this.sage_update({
                kill: true,
                auto: true
              });
              _this._set_content_and_sync();
              return cb();
            });
          };
        })(this)
      ], (function(_this) {
        return function(err) {
          return typeof cb === "function" ? cb(err, _this) : void 0;
        };
      })(this));
    }

    CodeMirrorSession.prototype.sage_socket = function(cb) {
      var e;
      if (this._sage_socket != null) {
        try {
          process.kill(this._sage_socket.pid, 0);
          cb(false, this._sage_socket);
          return;
        } catch (_error) {
          e = _error;
          this._sage_socket = void 0;
        }
      }
      winston.debug("sage_socket: initalize the newly started sage process");
      if (this.diffsync_fileclient != null) {
        this.sage_update({
          kill: true
        });
      }
      return get_sage_socket((function(_this) {
        return function(err, socket) {
          var mesg;
          if (err) {
            winston.debug("sage_socket: fail -- " + err + ".");
            return cb(err);
          } else {
            winston.debug("sage_socket: successfully opened a Sage session for worksheet '" + _this.path + "'");
            _this._sage_socket = socket;
            mesg = message.execute_code({
              id: misc.uuid(),
              code: "os.chdir(salvus.data['path']);__file__=salvus.data['file']",
              data: {
                path: misc.path_split(_this.path).head,
                file: abspath(_this.path)
              },
              preparse: false
            });
            socket.write_mesg('json', mesg);
            socket.on('end', function() {
              _this._sage_socket = void 0;
              return winston.debug("codemirror session " + _this.session_uuid + " sage socket terminated.");
            });
            socket.on('mesg', function(type, mesg) {
              var bcast, before, c, client_id, ds_client, error, hub, m, resp, sha1, x, y;
              switch (type) {
                case 'blob':
                  sha1 = mesg.uuid;
                  if (_this.diffsync_clients.length === 0) {
                    error = 'no global hubs are connected to the local hub, so nowhere to send file';
                    winston.debug("codemirror session: got blob from sage session -- " + error);
                    resp = message.save_blob({
                      error: error,
                      sha1: sha1
                    });
                    return socket.write_mesg('json', resp);
                  } else {
                    winston.debug("codemirror session: got blob from sage session -- forwarding to a random hub");
                    hub = misc.random_choice_from_obj(_this.diffsync_clients);
                    client_id = hub[0];
                    ds_client = hub[1];
                    mesg.client_id = client_id;
                    ds_client.remote.socket.write_mesg('blob', mesg);
                    return receive_save_blob_message({
                      sha1: sha1,
                      cb: function(resp) {
                        return socket.write_mesg('json', resp);
                      }
                    });
                  }
                  break;
                case 'json':
                  c = _this._sage_output_cb[mesg.id];
                  if (c != null) {
                    c(mesg);
                    if (mesg.done) {
                      delete _this._sage_output_cb[mesg.id];
                    }
                    return;
                  }
                  if (mesg.event === 'execute_javascript') {
                    mesg.session_uuid = _this.session_uuid;
                    bcast = message.codemirror_bcast({
                      session_uuid: _this.session_uuid,
                      mesg: mesg
                    });
                    _this.client_bcast(void 0, bcast);
                    return;
                  }
                  m = {};
                  for (x in mesg) {
                    y = mesg[x];
                    if (x !== 'id' && x !== 'event') {
                      if (x === 'done') {
                        if (y) {
                          m[x] = y;
                        }
                      } else {
                        m[x] = y;
                      }
                    }
                  }
                  before = _this.content;
                  _this.sage_output_mesg(mesg.id, m);
                  if (before !== _this.content) {
                    return _this._set_content_and_sync();
                  }
              }
            });
            if (_this.diffsync_fileclient != null) {
              _this.sage_update({
                auto: true
              });
            }
            return cb(false, _this._sage_socket);
          }
        };
      })(this));
    };

    CodeMirrorSession.prototype._set_content_and_sync = function() {
      var ds_client, id, ref1, results;
      if (this.set_content(this.content)) {
        ref1 = this.diffsync_clients;
        results = [];
        for (id in ref1) {
          ds_client = ref1[id];
          results.push(ds_client.remote.sync_ready());
        }
        return results;
      }
    };

    CodeMirrorSession.prototype.sage_execute_cell = function(id) {
      var code, output_id, ref1;
      winston.debug("exec request for cell with id: '" + id + "'");
      this.sage_remove_cell_flag(id, diffsync.FLAGS.execute);
      ref1 = this.sage_initialize_cell_for_execute(id), code = ref1.code, output_id = ref1.output_id;
      winston.debug("exec code '" + code + "'; output id='" + output_id + "'");
      this.set_content(this.content);
      if (code !== "") {
        this._sage_output_to_input_id[output_id] = id;
        winston.debug("start running -- " + id);
        this.sage_set_cell_flag(id, diffsync.FLAGS.running);
        this.sage_set_cell_flag(id, diffsync.FLAGS.this_session);
        this._set_content_and_sync();
        return this.sage_socket((function(_this) {
          return function(err, socket) {
            if (err) {
              winston.debug("Error getting sage socket: " + err);
              _this.sage_output_mesg(output_id, {
                stderr: "Error getting sage socket (unable to execute code): " + err
              });
              _this.sage_remove_cell_flag(id, diffsync.FLAGS.running);
              return;
            }
            winston.debug("Sending execute message to sage socket.");
            return socket.write_mesg('json', message.execute_code({
              id: output_id,
              cell_id: id,
              code: code,
              preparse: true
            }));
          };
        })(this));
      }
    };

    CodeMirrorSession.prototype.sage_execute_code = function(client_socket, mesg) {
      var client_id;
      client_id = mesg.client_id;
      this._sage_output_cb[mesg.id] = (function(_this) {
        return function(resp) {
          resp.client_id = client_id;
          return client_socket.write_mesg('json', resp);
        };
      })(this);
      return this.sage_socket((function(_this) {
        return function(err, socket) {
          var resp;
          if (err) {
            resp = message.output({
              stderr: "Error getting sage socket (unable to execute code): " + err,
              done: true
            });
            return client_socket.write_mesg('json', resp);
          } else {
            mesg.event = 'execute_code';
            return socket.write_mesg('json', mesg);
          }
        };
      })(this));
    };

    CodeMirrorSession.prototype.sage_raw_input = function(client_socket, mesg) {
      winston.debug("sage_raw_input '" + (misc.to_json(mesg)));
      return this.sage_socket((function(_this) {
        return function(err, socket) {
          if (err) {
            return winston.debug("sage_raw_input: error getting sage socket -- " + err);
          } else {
            return socket.write_mesg('json', mesg);
          }
        };
      })(this));
    };

    CodeMirrorSession.prototype.sage_call = function(opts) {
      var f;
      opts = defaults(opts, {
        mesg: required,
        cb: void 0
      });
      f = (function(_this) {
        return function(resp) {
          if (typeof opts.cb === "function") {
            opts.cb(false, resp);
          }
          return delete _this._sage_output_cb[opts.mesg.id];
        };
      })(this);
      return this.sage_socket((function(_this) {
        return function(err, socket) {
          if (err) {
            return typeof opts.cb === "function" ? opts.cb("error getting sage socket -- " + err) : void 0;
          } else {
            _this._sage_output_cb[opts.mesg.id] = f;
            return socket.write_mesg('json', opts.mesg);
          }
        };
      })(this));
    };

    CodeMirrorSession.prototype.sage_introspect = function(client_socket, mesg) {
      mesg.event = 'introspect';
      return this.sage_call({
        mesg: mesg,
        cb: (function(_this) {
          return function(err, resp) {
            if (err) {
              resp = message.error({
                error: "Error getting sage socket (unable to introspect): " + err
              });
              return client_socket.write_mesg('json', resp);
            } else {
              return client_socket.write_mesg('json', resp);
            }
          };
        })(this)
      });
    };

    CodeMirrorSession.prototype.send_signal_to_sage_session = function(client_socket, mesg) {
      if (this._sage_socket != null) {
        process_kill(this._sage_socket.pid, mesg.signal);
      }
      if ((mesg.id != null) && (client_socket != null)) {
        return client_socket.write_mesg('json', message.signal_sent({
          id: mesg.id
        }));
      }
    };

    CodeMirrorSession.prototype.sage_update = function(opts) {
      var flags, i, id, j, l, len, len1, new_flags, o, prev_ids, ref1, ref2, ref3, results, t, z;
      if (opts == null) {
        opts = {};
      }
      opts = defaults(opts, {
        kill: false,
        auto: false
      });
      if (this.content == null) {
        return;
      }
      winston.debug("sage_update");
      i = 0;
      prev_ids = {};
      z = 0;
      results = [];
      while (true) {
        z += 1;
        if (z > 5000) {
          winston.debug("sage_update: ERROR -- hit a possible infinite loop; opts=" + (misc.to_json(opts)));
          break;
        }
        i = this.content.indexOf(diffsync.MARKERS.cell, i);
        if (i === -1) {
          break;
        }
        j = this.content.indexOf(diffsync.MARKERS.cell, i + 1);
        if (j === -1) {
          break;
        }
        id = this.content.slice(i + 1, i + 37);
        if (misc.is_valid_uuid_string(id)) {
          if (prev_ids[id] != null) {
            id = uuid.v4();
            this.content = this.content.slice(0, i + 1) + id + this.content.slice(i + 37);
            flags = this.content.slice(i + 37, j);
            if (ref1 = diffsync.FLAGS.running, indexOf.call(flags, ref1) >= 0) {
              new_flags = '';
              for (l = 0, len = flags.length; l < len; l++) {
                t = flags[l];
                if (t !== diffsync.FLAGS.running) {
                  new_flags += t;
                }
              }
              this.content = this.content.slice(0, i + 37) + new_flags + this.content.slice(j);
            }
          }
          prev_ids[id] = true;
          flags = this.content.slice(i + 37, j);
          if (opts.kill || opts.auto) {
            if (opts.kill) {
              new_flags = '';
              for (o = 0, len1 = flags.length; o < len1; o++) {
                t = flags[o];
                if (t !== diffsync.FLAGS.running && t !== diffsync.FLAGS.this_session) {
                  new_flags += t;
                }
              }
              if (flags !== new_flags) {
                this.content = this.content.slice(0, i + 37) + new_flags + this.content.slice(j);
              }
            }
            if (opts.auto && (ref2 = diffsync.FLAGS.auto, indexOf.call(flags, ref2) >= 0)) {
              this.sage_remove_cell_flag(id, diffsync.FLAGS.auto);
              this.sage_execute_cell(id);
            }
          } else if (ref3 = diffsync.FLAGS.execute, indexOf.call(flags, ref3) >= 0) {
            this.sage_execute_cell(id);
          }
        }
        i = this.content.indexOf('\n', j + 1);
        if (i === -1) {
          break;
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    CodeMirrorSession.prototype.sage_output_mesg = function(output_id, mesg) {
      var bcast, cell_id, flag, i, k, msg, n;
      cell_id = this._sage_output_to_input_id[output_id];
      if (mesg.hide != null) {
        flag = void 0;
        if (mesg.hide === 'input') {
          flag = diffsync.FLAGS.hide_input;
        } else if (mesg.hide === 'output') {
          flag = diffsync.FLAGS.hide_output;
        }
        if (flag != null) {
          this.sage_set_cell_flag(cell_id, flag);
        } else {
          winston.debug("invalid hide component: '" + mesg.hide + "'");
        }
        delete mesg.hide;
      }
      if (mesg.show != null) {
        flag = void 0;
        if (mesg.show === 'input') {
          flag = diffsync.FLAGS.hide_input;
        } else if (mesg.show === 'output') {
          flag = diffsync.FLAGS.hide_output;
        }
        if (flag != null) {
          this.sage_remove_cell_flag(cell_id, flag);
        } else {
          winston.debug("invalid hide component: '" + mesg.hide + "'");
        }
        delete mesg.show;
      }
      if (mesg.auto != null) {
        if (mesg.auto) {
          this.sage_set_cell_flag(cell_id, diffsync.FLAGS.auto);
        } else {
          this.sage_remove_cell_flag(cell_id, diffsync.FLAGS.auto);
        }
      }
      if ((mesg.done != null) && mesg.done && (cell_id != null)) {
        this.sage_remove_cell_flag(cell_id, diffsync.FLAGS.running);
        delete this._sage_output_to_input_id[output_id];
        delete mesg.done;
        if (/^\s\s*/.test(mesg.stdout)) {
          delete mesg.stdout;
        }
        if (/^\s\s*/.test(mesg.stderr)) {
          delete mesg.stderr;
        }
      }
      if (misc.is_empty_object(mesg)) {
        return;
      }
      if ((mesg.once != null) && mesg.once) {
        if (mesg.javascript != null) {
          msg = message.execute_javascript({
            session_uuid: this.session_uuid,
            code: mesg.javascript.code,
            coffeescript: mesg.javascript.coffeescript,
            obj: mesg.obj,
            cell_id: cell_id
          });
          bcast = message.codemirror_bcast({
            session_uuid: this.session_uuid,
            mesg: msg
          });
          this.client_bcast(void 0, bcast);
          return;
        }
      }
      i = this.content.indexOf(diffsync.MARKERS.output + output_id);
      if (i === -1) {
        winston.debug("WORKSHEET: no such output cell (ignoring) -- " + output_id);
        return;
      }
      n = this.content.indexOf('\n', i);
      if (n === -1) {
        winston.debug("WORKSHEET: output cell corrupted (ignoring) -- " + output_id);
        return;
      }
      if (mesg.clear != null) {
        k = i + (diffsync.MARKERS.output + output_id).length + 1;
        this.content = this.content.slice(0, k) + this.content.slice(n);
        return;
      }
      if (mesg.delete_last != null) {
        k = this.content.lastIndexOf(diffsync.MARKERS.output, n - 2);
        this.content = this.content.slice(0, k + 1) + this.content.slice(n);
        return;
      }
      return this.content = this.content.slice(0, n) + JSON.stringify(mesg) + diffsync.MARKERS.output + this.content.slice(n);
    };

    CodeMirrorSession.prototype.sage_find_cell_meta = function(id, start) {
      var i, j;
      i = this.content.indexOf(diffsync.MARKERS.cell + id, start);
      j = this.content.indexOf(diffsync.MARKERS.cell, i + 1);
      if (j === -1) {
        return void 0;
      }
      return {
        start: i,
        end: j
      };
    };

    CodeMirrorSession.prototype.sage_get_cell_flagstring = function(id) {
      var pos;
      pos = this.sage_find_cell_meta(id);
      return this.content.slice(pos.start + 37, pos.end);
    };

    CodeMirrorSession.prototype.sage_set_cell_flagstring = function(id, flags) {
      var pos;
      pos = this.sage_find_cell_meta(id);
      if (pos != null) {
        return this.content = this.content.slice(0, pos.start + 37) + flags + this.content.slice(pos.end);
      }
    };

    CodeMirrorSession.prototype.sage_set_cell_flag = function(id, flag) {
      var s;
      s = this.sage_get_cell_flagstring(id);
      if (indexOf.call(s, flag) < 0) {
        return this.sage_set_cell_flagstring(id, flag + s);
      }
    };

    CodeMirrorSession.prototype.sage_remove_cell_flag = function(id, flag) {
      var s;
      s = this.sage_get_cell_flagstring(id);
      if (indexOf.call(s, flag) >= 0) {
        s = s.replace(new RegExp(flag, "g"), "");
        return this.sage_set_cell_flagstring(id, s);
      }
    };

    CodeMirrorSession.prototype.sage_initialize_cell_for_execute = function(id, start) {
      var cell_start, code, code_start, newline, next_cell, next_cell_start, output, output_end, output_id, output_insert, output_start;
      cell_start = this.content.indexOf(diffsync.MARKERS.cell + id, start);
      if (cell_start === -1) {
        return;
      }
      code_start = this.content.indexOf(diffsync.MARKERS.cell, cell_start + 1);
      if (code_start === -1) {
        return;
      }
      newline = this.content.indexOf('\n', cell_start);
      next_cell = this.content.indexOf(diffsync.MARKERS.cell, code_start + 1);
      if (newline === -1) {
        output_start = this.content.length;
        this.content += '\n\n\n\n\n';
        winston.debug("Add a new input cell at the very end (which will be after the output).");
      } else {
        while (true) {
          next_cell_start = this.content.indexOf(diffsync.MARKERS.cell, newline);
          if (next_cell_start === -1) {
            next_cell_start = this.content.search(/\s+$/);
            if (next_cell_start === -1) {
              next_cell_start = this.content.length + 1;
              this.content += '\n\n\n\n\n';
            } else {
              while (next_cell_start < this.content.length && this.content[next_cell_start] !== '\n') {
                next_cell_start += 1;
              }
              if (this.content[next_cell_start] !== '\n') {
                this.content += '\n\n\n\n\n';
              }
              next_cell_start += 1;
            }
          }
          output = this.content.indexOf(diffsync.MARKERS.output, newline);
          if (output === -1 || output > next_cell_start) {
            output_start = next_cell_start;
            break;
          } else {
            output_end = this.content.indexOf('\n', output + 1);
            this.content = this.content.slice(0, output) + this.content.slice(output_end + 1);
          }
        }
      }
      code = this.content.slice(code_start + 1, output_start);
      output_id = uuid.v4();
      if (output_start > 0 && this.content[output_start - 1] !== '\n') {
        output_insert = '\n';
      } else {
        output_insert = '';
      }
      output_insert += diffsync.MARKERS.output + output_id + diffsync.MARKERS.output + '\n';
      if (next_cell === -1) {
        output_insert += diffsync.MARKERS.cell + uuid.v4() + diffsync.MARKERS.cell + '\n';
      }
      this.content = this.content.slice(0, output_start) + output_insert + this.content.slice(output_start);
      return {
        code: code.trim(),
        output_id: output_id
      };
    };

    CodeMirrorSession.prototype.kill = function() {
      winston.debug("Killing session " + this.session_uuid);
      this.sync_filesystem((function(_this) {
        return function() {
          _this.diffsync_fileserver.kill();
          delete _this.content;
          delete _this.diffsync_fileclient;
          return delete _this.diffsync_fileserver;
        };
      })(this));
      if (this._sage_socket != null) {
        this._sage_socket.end();
        if (this._sage_socket.pid != null) {
          return setTimeout(((function(_this) {
            return function() {
              return process_kill(_this._sage_socket.pid, 9);
            };
          })(this)), 3000);
        }
      }
    };

    CodeMirrorSession.prototype.set_content = function(value) {
      var changed, ds_client, id, ref1;
      this.is_active = true;
      changed = false;
      if (this.content !== value) {
        this.content = value;
        changed = true;
      }
      if (this.diffsync_fileclient.live !== value) {
        this.diffsync_fileclient.live = value;
        changed = true;
      }
      ref1 = this.diffsync_clients;
      for (id in ref1) {
        ds_client = ref1[id];
        if (ds_client.live !== value) {
          changed = true;
          ds_client.live = value;
        }
      }
      return changed;
    };

    CodeMirrorSession.prototype.client_bcast = function(socket, mesg) {
      var client_id, ds_client, id, ref1, results;
      this.is_active = true;
      winston.debug("client_bcast: " + (json(mesg)));
      client_id = mesg.client_id;
      ref1 = this.diffsync_clients;
      results = [];
      for (id in ref1) {
        ds_client = ref1[id];
        if (client_id !== id) {
          mesg.client_id = id;
          results.push(ds_client.remote.socket.write_mesg('json', mesg));
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    CodeMirrorSession.prototype.client_diffsync = function(socket, mesg) {
      var before, ds_client, write_mesg;
      this.is_active = true;
      write_mesg = function(event, obj) {
        if (obj == null) {
          obj = {};
        }
        obj.id = mesg.id;
        return socket.write_mesg('json', message[event](obj));
      };
      ds_client = this.diffsync_clients[mesg.client_id];
      if (ds_client == null) {
        write_mesg('error', {
          error: "client " + mesg.client_id + " not registered for synchronization"
        });
        return;
      }
      if (this._client_sync_lock) {
        winston.debug("client_diffsync hit a click_sync_lock -- send retry message back");
        write_mesg('error', {
          error: "retry"
        });
        return;
      }
      if (this._filesystem_sync_lock) {
        if (this._filesystem_sync_lock < new Date()) {
          this._filesystem_sync_lock = false;
        } else {
          winston.debug("client_diffsync hit a filesystem_sync_lock -- send retry message back");
          write_mesg('error', {
            error: "retry"
          });
          return;
        }
      }
      this._client_sync_lock = true;
      before = this.content;
      return ds_client.recv_edits(mesg.edit_stack, mesg.last_version_ack, (function(_this) {
        return function(err) {
          _this.set_content(ds_client.live);
          _this._client_sync_lock = false;
          if (typeof _this.process_new_content === "function") {
            _this.process_new_content();
          }
          ds_client.remote.current_mesg_id = mesg.id;
          return ds_client.push_edits(function(err) {
            var changed;
            if (err) {
              return winston.debug("CodeMirrorSession -- client push_edits returned -- " + err);
            } else {
              changed = before !== _this.content;
              if (changed) {
                _this.tell_clients_to_update(mesg.client_id);
                return _this.update_revision_tracking();
              }
            }
          });
        };
      })(this));
    };

    CodeMirrorSession.prototype.tell_clients_to_update = function(exclude) {
      var ds_client, id, ref1, results;
      ref1 = this.diffsync_clients;
      results = [];
      for (id in ref1) {
        ds_client = ref1[id];
        if (exclude !== id) {
          results.push(ds_client.remote.sync_ready());
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    CodeMirrorSession.prototype.sync_filesystem = function(cb) {
      var before;
      this.is_active = true;
      if (this._client_sync_lock) {
        winston.debug("sync_filesystem -- hit client sync lock");
        if (typeof cb === "function") {
          cb("cannot sync with filesystem while syncing with clients");
        }
        return;
      }
      if (this._filesystem_sync_lock) {
        if (this._filesystem_sync_lock < new Date()) {
          this._filesystem_sync_lock = false;
        } else {
          winston.debug("sync_filesystem -- hit filesystem sync lock");
          if (typeof cb === "function") {
            cb("cannot sync with filesystem; already syncing");
          }
          return;
        }
      }
      before = this.content;
      if (this.diffsync_fileclient == null) {
        if (typeof cb === "function") {
          cb("filesystem sync object (@diffsync_fileclient) no longer defined");
        }
        return;
      }
      this._filesystem_sync_lock = expire_time(10);
      return this.diffsync_fileclient.sync((function(_this) {
        return function(err) {
          var ds_client, id, ref1;
          if (err) {
            winston.debug("@diffsync_fileclient.sync -- returned an error -- " + err);
            _this.diffsync_fileserver.kill();
            _this.diffsync_fileserver = new DiffSyncFile_server(_this, function(err, ignore_content) {
              if (err) {
                winston.debug("@diffsync_fileclient.sync -- making new server failed: " + err);
                _this._filesystem_sync_lock = false;
                if (typeof cb === "function") {
                  cb(err);
                }
                return;
              }
              _this.diffsync_fileclient = new DiffSyncFile_client(_this.diffsync_fileserver);
              _this.diffsync_fileclient.live = _this.content;
              return _this.diffsync_fileclient.sync(function(err) {
                if (err) {
                  winston.debug("@diffsync_fileclient.sync -- making server worked but re-sync failed -- " + err);
                  _this._filesystem_sync_lock = false;
                  return typeof cb === "function" ? cb("codemirror fileclient sync error -- '" + err + "'") : void 0;
                } else {
                  _this._filesystem_sync_lock = false;
                  return typeof cb === "function" ? cb() : void 0;
                }
              });
            });
            return;
          }
          if (_this.diffsync_fileclient.live !== _this.content) {
            _this.set_content(_this.diffsync_fileclient.live);
            ref1 = _this.diffsync_clients;
            for (id in ref1) {
              ds_client = ref1[id];
              ds_client.remote.sync_ready();
            }
          }
          _this._filesystem_sync_lock = false;
          return typeof cb === "function" ? cb() : void 0;
        };
      })(this));
    };

    CodeMirrorSession.prototype.add_client = function(socket, client_id) {
      var ds_client;
      this.is_active = true;
      ds_client = new diffsync.DiffSync({
        doc: this.content
      });
      ds_client.connect(new CodeMirrorDiffSyncHub(socket, this.session_uuid, client_id));
      this.diffsync_clients[client_id] = ds_client;
      winston.debug("CodeMirrorSession(" + this.path + ").add_client(client_id=" + client_id + ") -- now we have " + (misc.len(this.diffsync_clients)) + " clients.");
      return socket.on('end', (function(_this) {
        return function() {
          winston.debug("DISCONNECT: socket connection " + socket.id + " from global hub disconected.");
          return delete _this.diffsync_clients[client_id];
        };
      })(this));
    };

    CodeMirrorSession.prototype.remove_client = function(socket, client_id) {
      return delete this.diffsync_clients[client_id];
    };

    CodeMirrorSession.prototype.write_to_disk = function(socket, mesg) {
      this.is_active = true;
      winston.debug("write_to_disk: " + (json(mesg)) + " -- calling sync_filesystem");
      return this.sync_filesystem((function(_this) {
        return function(err) {
          var resp;
          if (err) {
            resp = message.error({
              id: mesg.id,
              error: "Error writing file '" + _this.path + "' to disk -- " + err
            });
          } else {
            resp = message.codemirror_wrote_to_disk({
              id: mesg.id,
              hash: misc.hash_string(_this.content)
            });
          }
          return socket.write_mesg('json', resp);
        };
      })(this));
    };

    CodeMirrorSession.prototype.read_from_disk = function(socket, mesg) {
      return async.series([
        (function(_this) {
          return function(cb) {
            return fs.stat(function(err, stats) {
              if (err) {
                return cb(err);
              } else {
                return cb(check_file_size(stats.size));
              }
            });
          };
        })(this), (function(_this) {
          return function(cb) {
            return fs.readFile(_this.path, function(err, data) {
              var ds, id, ref1, value;
              if (err) {
                return cb("Error reading file '" + _this.path + "' from disk -- " + err);
              } else {
                value = data.toString();
                if (value !== _this.content) {
                  _this.set_content(value);
                  ref1 = _this.diffsync_clients;
                  for (id in ref1) {
                    ds = ref1[id];
                    ds.remote.sync_ready();
                  }
                }
                return cb();
              }
            });
          };
        })(this)
      ], (function(_this) {
        return function(err) {
          if (err) {
            return socket.write_mesg('json', message.error({
              id: mesg.id,
              error: err
            }));
          } else {
            return socket.write_mesg('json', message.success({
              id: mesg.id
            }));
          }
        };
      })(this));
    };

    CodeMirrorSession.prototype.get_content = function(socket, mesg) {
      this.is_active = true;
      return socket.write_mesg('json', message.codemirror_content({
        id: mesg.id,
        content: this.content
      }));
    };

    CodeMirrorSession.prototype.revision_tracking = function(socket, mesg) {
      var d;
      winston.debug("revision_tracking for " + this.path + ": " + mesg.enable);
      d = function(m) {
        return winston.debug("revision_tracking for " + this.path + ": " + m);
      };
      if (mesg.enable) {
        d("enable it");
        if (this.revision_tracking_doc != null) {
          d("already enabled");
          return socket.write_mesg('json', message.success({
            id: mesg.id
          }));
        } else {
          if (this.readonly) {
            socket.write_mesg('json', message.success({
              id: mesg.id
            }));
            return;
          }
          d("need to enable");
          return codemirror_sessions.connect({
            mesg: {
              path: revision_tracking_path(this.path),
              project_id: INFO.project_id
            },
            cb: (function(_this) {
              return function(err, session) {
                d("got response -- " + err);
                if (err) {
                  return socket.write_mesg('json', message.error({
                    id: mesg.id,
                    error: err
                  }));
                } else {
                  _this.revision_tracking_doc = session;
                  socket.write_mesg('json', message.success({
                    id: mesg.id
                  }));
                  return _this.update_revision_tracking();
                }
              };
            })(this)
          });
        }
      } else {
        d("disable it");
        delete this.revision_tracking_doc;
        return socket.write_mesg('json', message.success({
          id: mesg.id
        }));
      }
    };

    CodeMirrorSession.prototype.update_revision_tracking = function() {
      var entry, f, i, patch;
      if (this.revision_tracking_doc == null) {
        return;
      }
      winston.debug("update revision tracking data - " + this.path);
      if (this.revision_tracking_doc.HEAD == null) {
        if (this.revision_tracking_doc.content.length === 0) {
          this.revision_tracking_doc.HEAD = this.content;
          this.revision_tracking_doc.content = misc.to_json(this.content);
        } else {
          i = this.revision_tracking_doc.content.indexOf('\n');
          if (i === -1) {
            this.revision_tracking_doc.HEAD = misc.from_json(this.revision_tracking_doc.content);
          } else {
            this.revision_tracking_doc.HEAD = misc.from_json(this.revision_tracking_doc.content.slice(0, i));
          }
        }
      }
      if (this.revision_tracking_doc.HEAD !== this.content) {
        patch = diffsync.dmp.patch_make(this.content, this.revision_tracking_doc.HEAD);
        this.revision_tracking_doc.HEAD = this.content;
        i = this.revision_tracking_doc.content.indexOf('\n');
        entry = {
          patch: diffsync.compress_patch(patch),
          time: new Date() - 0
        };
        this.revision_tracking_doc.content = misc.to_json(this.content) + '\n' + misc.to_json(entry) + (i !== -1 ? this.revision_tracking_doc.content.slice(i) : "");
      }
      this.revision_tracking_doc._set_content_and_sync();
      if (this.revision_tracking_save_timer == null) {
        f = (function(_this) {
          return function() {
            delete _this.revision_tracking_save_timer;
            return _this.revision_tracking_doc.sync_filesystem();
          };
        })(this);
        return this.revision_tracking_save_timer = setInterval(f, REVISION_TRACKING_SAVE_INTERVAL);
      }
    };

    return CodeMirrorSession;

  })();

  CodeMirrorSessions = (function() {
    function CodeMirrorSessions() {
      this.handle_mesg = bind(this.handle_mesg, this);
      this.info = bind(this.info, this);
      this.add_session_to_cache = bind(this.add_session_to_cache, this);
      this.connect = bind(this.connect, this);
      this._sessions = {
        by_uuid: {},
        by_path: {},
        by_project: {}
      };
    }

    CodeMirrorSessions.prototype.connect = function(opts) {
      var finish, mesg, session;
      opts = defaults(opts, {
        client_socket: void 0,
        mesg: required,
        cb: void 0
      });
      mesg = opts.mesg;
      finish = function(session) {
        if (opts.client_socket == null) {
          return;
        }
        session.add_client(opts.client_socket, mesg.client_id);
        return opts.client_socket.write_mesg('json', message.codemirror_session({
          id: mesg.id,
          session_uuid: session.session_uuid,
          path: session.path,
          content: session.content,
          readonly: session.readonly
        }));
      };
      if (mesg.session_uuid != null) {
        session = this._sessions.by_uuid[mesg.session_uuid];
        if (session != null) {
          finish(session);
          if (typeof opts.cb === "function") {
            opts.cb(void 0, session);
          }
          return;
        }
      }
      if (mesg.path != null) {
        session = this._sessions.by_path[mesg.path];
        if (session != null) {
          finish(session);
          if (typeof opts.cb === "function") {
            opts.cb(void 0, session);
          }
          return;
        }
      }
      mesg.session_uuid = uuid.v4();
      return new CodeMirrorSession(mesg, (function(_this) {
        return function(err, session) {
          var ref1;
          if (err) {
            if ((ref1 = opts.client_socket) != null) {
              ref1.write_mesg('json', message.error({
                id: mesg.id,
                error: err
              }));
            }
            return typeof opts.cb === "function" ? opts.cb(err) : void 0;
          } else {
            _this.add_session_to_cache({
              session: session,
              project_id: mesg.project_id,
              timeout: 3600
            });
            finish(session);
            return typeof opts.cb === "function" ? opts.cb(void 0, session) : void 0;
          }
        };
      })(this));
    };

    CodeMirrorSessions.prototype.add_session_to_cache = function(opts) {
      var destroy, destroy_if_inactive;
      opts = defaults(opts, {
        session: required,
        project_id: void 0,
        timeout: void 0
      });
      winston.debug("Adding session " + opts.session.session_uuid + " (of project " + opts.project_id + ") to cache.");
      this._sessions.by_uuid[opts.session.session_uuid] = opts.session;
      this._sessions.by_path[opts.session.path] = opts.session;
      if (opts.project_id != null) {
        if (this._sessions.by_project[opts.project_id] == null) {
          this._sessions.by_project[opts.project_id] = {};
        }
        this._sessions.by_project[opts.project_id][opts.session.path] = opts.session;
      }
      destroy = (function(_this) {
        return function() {
          var x;
          opts.session.kill();
          delete _this._sessions.by_uuid[opts.session.session_uuid];
          delete _this._sessions.by_path[opts.session.path];
          x = _this._sessions.by_project[opts.project_id];
          if (x != null) {
            return delete x[opts.session.path];
          }
        };
      })(this);
      if (opts.timeout != null) {
        destroy_if_inactive = (function(_this) {
          return function() {
            if (!((opts.session.is_active != null) && opts.session.is_active)) {
              winston.debug("Session " + opts.session.session_uuid + " is inactive for " + opts.timeout + " seconds; killing.");
              return destroy();
            } else {
              opts.session.is_active = false;
              winston.debug("Starting a new activity check timer for session " + opts.session.session_uuid + ".");
              return setTimeout(destroy_if_inactive, opts.timeout * 1000);
            }
          };
        })(this);
        return setTimeout(destroy_if_inactive, opts.timeout * 1000);
      }
    };

    CodeMirrorSessions.prototype.info = function(project_id) {
      var X, obj, path, session;
      obj = {};
      X = this._sessions.by_project[project_id];
      if (X != null) {
        for (path in X) {
          session = X[path];
          obj[session.session_uuid] = {
            path: session.path
          };
        }
      }
      return obj;
    };

    CodeMirrorSessions.prototype.handle_mesg = function(client_socket, mesg) {
      var session;
      winston.debug("CodeMirrorSessions.handle_mesg: '" + (json(mesg)) + "'");
      if (mesg.event === 'codemirror_get_session') {
        this.connect({
          client_socket: client_socket,
          mesg: mesg
        });
        return;
      }
      session = this._sessions.by_uuid[mesg.session_uuid];
      if (session == null) {
        winston.debug("codemirror.handle_mesg -- Unknown CodeMirror session: " + mesg.session_uuid + ".");
        client_socket.write_mesg('json', message.error({
          id: mesg.id,
          error: "Unknown CodeMirror session: " + mesg.session_uuid + "."
        }));
        return;
      }
      switch (mesg.event) {
        case 'codemirror_diffsync':
          return session.client_diffsync(client_socket, mesg);
        case 'codemirror_bcast':
          return session.client_bcast(client_socket, mesg);
        case 'codemirror_write_to_disk':
          return session.write_to_disk(client_socket, mesg);
        case 'codemirror_read_from_disk':
          return session.read_from_disk(client_socket, mesg);
        case 'codemirror_get_content':
          return session.get_content(client_socket, mesg);
        case 'codemirror_revision_tracking':
          return session.revision_tracking(client_socket, mesg);
        case 'codemirror_execute_code':
          return session.sage_execute_code(client_socket, mesg);
        case 'codemirror_introspect':
          return session.sage_introspect(client_socket, mesg);
        case 'codemirror_send_signal':
          return session.send_signal_to_sage_session(client_socket, mesg);
        case 'codemirror_disconnect':
          session.remove_client(client_socket, mesg.client_id);
          return client_socket.write_mesg('json', message.success({
            id: mesg.id
          }));
        case 'codemirror_sage_raw_input':
          return session.sage_raw_input(client_socket, mesg);
        default:
          return client_socket.write_mesg('json', message.error({
            id: mesg.id,
            error: "unknown CodeMirror session event: " + mesg.event + "."
          }));
      }
    };

    return CodeMirrorSessions;

  })();

  codemirror_sessions = new CodeMirrorSessions();

  connect_to_session = function(socket, mesg) {
    var err;
    winston.debug("connect_to_session -- type='" + mesg.type + "'");
    switch (mesg.type) {
      case 'console':
        return console_sessions.connect(socket, mesg);
      case 'sage':
        return sage_sessions.connect(socket, mesg);
      default:
        err = message.error({
          id: mesg.id,
          error: "Unsupported session type '" + mesg.type + "'"
        });
        return socket.write_mesg('json', err);
    }
  };

  terminate_session = function(socket, mesg) {
    var cb, sid;
    cb = function(err) {
      if (err) {
        mesg = message.error({
          id: mesg.id,
          error: err
        });
      }
      return socket.write_mesg('json', mesg);
    };
    sid = mesg.session_uuid;
    if (console_sessions.session_exists(sid)) {
      return console_sessions.terminate_session(sid, cb);
    } else if (sage_sessions.session_exists(sid)) {
      return sage_sessions.terminate_session(sid, cb);
    } else {
      return cb();
    }
  };

  read_file_from_project = function(socket, mesg) {
    var archive, data, id, is_dir, path, stats;
    data = void 0;
    path = abspath(mesg.path);
    is_dir = void 0;
    id = void 0;
    archive = void 0;
    stats = void 0;
    return async.series([
      function(cb) {
        return fs.stat(path, function(err, _stats) {
          if (err) {
            return cb(err);
          } else {
            stats = _stats;
            is_dir = stats.isDirectory();
            return cb();
          }
        });
      }, function(cb) {
        return cb(check_file_size(stats.size));
      }, function(cb) {
        var args, split, target;
        if (is_dir) {
          if (mesg.archive !== 'tar.bz2') {
            cb("The only supported directory archive format is tar.bz2");
            return;
          }
          target = temp.path({
            suffix: '.' + mesg.archive
          });
          archive = mesg.archive;
          if (path[path.length - 1] === '/') {
            path = path.slice(0, path.length - 1);
          }
          split = misc.path_split(path);
          path = target;
          args = ["--exclude=.sagemathcloud*", '--exclude=.forever', '--exclude=.node*', '--exclude=.npm', '--exclude=.sage', '-jcf', target, split.tail];
          return child_process.execFile('tar', args, {
            cwd: split.head
          }, function(err, stdout, stderr) {
            if (err) {
              winston.debug("Issue creating tarball: " + err + ", " + stdout + ", " + stderr);
              return cb(err);
            } else {
              return cb();
            }
          });
        } else {
          return cb();
        }
      }, function(cb) {
        return fs.readFile(path, function(err, _data) {
          data = _data;
          return cb(err);
        });
      }, function(cb) {
        id = misc_node.uuidsha1(data);
        winston.debug("Hash = " + id);
        return cb();
      }, function(cb) {
        socket.write_mesg('json', message.file_read_from_project({
          id: mesg.id,
          data_uuid: id,
          archive: archive
        }));
        socket.write_mesg('blob', {
          uuid: id,
          blob: data
        });
        return cb();
      }
    ], function(err) {
      if (err && err !== 'file already known') {
        socket.write_mesg('json', message.error({
          id: mesg.id,
          error: err
        }));
      }
      if (is_dir) {
        return fs.exists(path, function(exists) {
          if (exists) {
            winston.debug("It was a directory, so remove the temporary archive '" + path + "'.");
            return fs.unlink(path);
          }
        });
      }
    });
  };

  write_file_to_project = function(socket, mesg) {
    var data_uuid, path, write_file;
    data_uuid = mesg.data_uuid;
    path = abspath(mesg.path);
    write_file = function(type, value) {
      if (type === 'blob' && value.uuid === data_uuid) {
        socket.removeListener('mesg', write_file);
        return async.series([
          function(cb) {
            return ensure_containing_directory_exists(path, cb);
          }, function(cb) {
            return fs.writeFile(path, value.blob, cb);
          }
        ], function(err) {
          if (err) {
            return socket.write_mesg('json', message.error({
              id: mesg.id,
              error: err
            }));
          } else {
            return socket.write_mesg('json', message.file_written_to_project({
              id: mesg.id
            }));
          }
        });
      }
    };
    return socket.on('mesg', write_file);
  };

  print_sagews = function(opts) {
    var args, extra_data_file;
    opts = defaults(opts, {
      path: required,
      outfile: required,
      title: required,
      author: required,
      date: required,
      contents: required,
      extra_data: void 0,
      timeout: 90,
      cb: required
    });
    extra_data_file = void 0;
    args = [opts.path, '--outfile', opts.outfile, '--title', opts.title, '--author', opts.author, '--date', opts.date, '--contents', opts.contents];
    return async.series([
      function(cb) {
        if (opts.extra_data == null) {
          cb();
          return;
        }
        extra_data_file = temp.path() + '.json';
        args.push('--extra_data_file');
        args.push(extra_data_file);
        return fs.writeFile(extra_data_file, opts.extra_data, cb);
      }, function(cb) {
        return misc_node.execute_code({
          command: "sagews2pdf.py",
          args: args,
          err_on_exit: false,
          bash: false,
          timeout: opts.timeout,
          cb: cb
        });
      }
    ], (function(_this) {
      return function(err) {
        if (extra_data_file != null) {
          fs.unlink(extra_data_file);
        }
        return opts.cb(err);
      };
    })(this));
  };

  print_to_pdf = function(socket, mesg) {
    var ext, pdf;
    ext = misc.filename_extension(mesg.path);
    if (ext) {
      pdf = (mesg.path.slice(0, mesg.path.length - ext.length)) + "pdf";
    } else {
      pdf = mesg.path + '.pdf';
    }
    return async.series([
      function(cb) {
        switch (ext) {
          case 'sagews':
            return print_sagews({
              path: mesg.path,
              outfile: pdf,
              title: mesg.options.title,
              author: mesg.options.author,
              date: mesg.options.date,
              contents: mesg.options.contents,
              extra_data: mesg.options.extra_data,
              timeout: mesg.options.timeout,
              cb: cb
            });
          default:
            return cb("unable to print file of type '" + ext + "'");
        }
      }
    ], function(err) {
      if (err) {
        return socket.write_mesg('json', message.error({
          id: mesg.id,
          error: err
        }));
      } else {
        return socket.write_mesg('json', message.printed_to_pdf({
          id: mesg.id,
          path: pdf
        }));
      }
    });
  };

  session_info = function(project_id) {
    return {
      'sage_sessions': sage_sessions.info(project_id),
      'console_sessions': console_sessions.info(project_id),
      'file_sessions': codemirror_sessions.info(project_id)
    };
  };

  jupyter_port_queue = [];

  jupyter_port = function(socket, mesg) {
    winston.debug("jupyter_port");
    jupyter_port_queue.push({
      socket: socket,
      mesg: mesg
    });
    if (jupyter_port_queue.length > 1) {
      return;
    }
    return misc_node.execute_code({
      command: "ipython-notebook",
      args: ['start'],
      err_on_exit: true,
      bash: false,
      timeout: 60,
      ulimit_timeout: false,
      cb: function(err, out) {
        var e, err_mesg, error, info, l, len, len1, o, port, resp, x;
        if (!err) {
          try {
            info = misc.from_json(out.stdout);
            port = info != null ? info.port : void 0;
            if (port == null) {
              err = "unable to start -- no port; info=" + (misc.to_json(out));
            } else {

            }
          } catch (_error) {
            e = _error;
            err = "error parsing ipython-notebook startup output -- " + e + ", {misc.to_json(out)}";
          }
        }
        if (err) {
          error = "error starting Jupyter -- " + err;
          for (l = 0, len = jupyter_port_queue.length; l < len; l++) {
            x = jupyter_port_queue[l];
            err_mesg = message.error({
              id: x.mesg.id,
              error: error
            });
            x.socket.write_mesg('json', err_mesg);
          }
        } else {
          for (o = 0, len1 = jupyter_port_queue.length; o < len1; o++) {
            x = jupyter_port_queue[o];
            resp = message.jupyter_port({
              port: port,
              id: x.mesg.id
            });
            x.socket.write_mesg('json', resp);
          }
        }
        return jupyter_port_queue = [];
      }
    });
  };

  project_exec = function(socket, mesg) {
    winston.debug("project_exec");
    if (mesg.command === "ipython-notebook") {
      socket.write_mesg("json", message.error({
        id: mesg.id,
        error: "old client code -- you may not run ipython-notebook directly"
      }));
      return;
    }
    return misc_node.execute_code({
      command: mesg.command,
      args: mesg.args,
      path: abspath(mesg.path),
      timeout: mesg.timeout,
      err_on_exit: mesg.err_on_exit,
      max_output: mesg.max_output,
      bash: mesg.bash,
      cb: function(err, out) {
        var err_mesg, error;
        if (err) {
          error = "Error executing command '" + mesg.command + "' with args '" + mesg.args + "' -- " + err + ", " + (out != null ? out.stdout : void 0) + ", " + (out != null ? out.stderr : void 0);
          if (error.indexOf("Connection refused") !== -1) {
            error += "-- Email help@sagemath.com if you need external network access, which is disabled by default.";
          }
          if (error.indexOf("=") !== -1) {
            error += "-- This is a BASH terminal, not a Sage worksheet.  For Sage, use +New and create a Sage worksheet.";
          }
          err_mesg = message.error({
            id: mesg.id,
            error: error
          });
          return socket.write_mesg('json', err_mesg);
        } else {
          return socket.write_mesg('json', message.project_exec_output({
            id: mesg.id,
            stdout: out.stdout,
            stderr: out.stderr,
            exit_code: out.exit_code
          }));
        }
      }
    });
  };

  _save_blob_callbacks = {};

  receive_save_blob_message = function(opts) {
    var f, id, sha1;
    opts = defaults(opts, {
      sha1: required,
      cb: required,
      timeout: 30
    });
    sha1 = opts.sha1;
    id = misc.uuid();
    if (_save_blob_callbacks[sha1] == null) {
      _save_blob_callbacks[sha1] = [[opts.cb, id]];
    } else {
      _save_blob_callbacks[sha1].push([opts.cb, id]);
    }
    f = function() {
      var l, len, mesg, v, w, x;
      v = _save_blob_callbacks[sha1];
      if (v != null) {
        mesg = message.save_blob({
          sha1: sha1,
          error: "timed out after local hub waited for " + opts.timeout + " seconds"
        });
        w = [];
        for (l = 0, len = v.length; l < len; l++) {
          x = v[l];
          if (x[1] === id) {
            x[0](mesg);
          } else {
            w.push(x);
          }
        }
        if (w.length === 0) {
          return delete _save_blob_callbacks[sha1];
        } else {
          return _save_blob_callbacks[sha1] = w;
        }
      }
    };
    if (opts.timeout) {
      return setTimeout(f, opts.timeout * 1000);
    }
  };

  handle_save_blob_message = function(mesg) {
    var l, len, v, x;
    v = _save_blob_callbacks[mesg.sha1];
    if (v != null) {
      for (l = 0, len = v.length; l < len; l++) {
        x = v[l];
        x[0](mesg);
      }
      return delete _save_blob_callbacks[mesg.sha1];
    }
  };

  handle_mesg = function(socket, mesg, handler) {
    var e, err, resp;
    activity();
    try {
      winston.debug("Handling '" + (json(mesg)) + "'");
      if (mesg.event.split('_')[0] === 'codemirror') {
        codemirror_sessions.handle_mesg(socket, mesg);
        return;
      }
      switch (mesg.event) {
        case 'connect_to_session':
        case 'start_session':
          socket.removeListener('mesg', handler);
          return connect_to_session(socket, mesg);
        case 'project_session_info':
          resp = message.project_session_info({
            id: mesg.id,
            project_id: mesg.project_id,
            info: session_info(mesg.project_id)
          });
          return socket.write_mesg('json', resp);
        case 'jupyter_port':
          return jupyter_port(socket, mesg);
        case 'project_exec':
          return project_exec(socket, mesg);
        case 'read_file_from_project':
          return read_file_from_project(socket, mesg);
        case 'write_file_to_project':
          return write_file_to_project(socket, mesg);
        case 'print_to_pdf':
          return print_to_pdf(socket, mesg);
        case 'send_signal':
          process_kill(mesg.pid, mesg.signal);
          if (mesg.id != null) {
            return socket.write_mesg('json', message.signal_sent({
              id: mesg.id
            }));
          }
          break;
        case 'terminate_session':
          return terminate_session(socket, mesg);
        case 'save_blob':
          return handle_save_blob_message(mesg);
        default:
          if (mesg.id != null) {
            err = message.error({
              id: mesg.id,
              error: "Local hub received an invalid mesg type '" + mesg.event + "'"
            });
          }
          return socket.write_mesg('json', err);
      }
    } catch (_error) {
      e = _error;
      winston.debug(new Error().stack);
      return winston.error("ERROR: '" + e + "' handling message '" + (json(mesg)) + "'");
    }
  };

  process_kill = function(pid, signal) {
    var e;
    switch (signal) {
      case 2:
        signal = 'SIGINT';
        break;
      case 3:
        signal = 'SIGQUIT';
        break;
      case 9:
        signal = 'SIGKILL';
        break;
      default:
        winston.debug("BUG -- process_kill: only signals 2 (SIGINT), 3 (SIGQUIT), and 9 (SIGKILL) are supported");
        return;
    }
    try {
      return process.kill(pid, signal);
    } catch (_error) {
      e = _error;
    }
  };

  server = net.createServer(function(socket) {
    winston.debug("PARENT: received connection");
    return misc_node.unlock_socket(socket, secret_token, function(err) {
      var handler;
      if (err) {
        return winston.debug(err);
      } else {
        socket.id = uuid.v4();
        misc_node.enable_mesg(socket);
        handler = function(type, mesg) {
          if (type === "json") {
            winston.debug("received control mesg " + (json(mesg)));
            return handle_mesg(socket, mesg, handler);
          }
        };
        return socket.on('mesg', handler);
      }
    });
  });

  start_tcp_server = function(cb) {
    winston.info("starting tcp server...");
    return server.listen(program.port, '0.0.0.0', function() {
      winston.info("listening on port " + (server.address().port));
      return fs.writeFile(abspath(DATA + "/local_hub.port"), server.address().port, cb);
    });
  };

  raw_server_domain = require('domain').create();

  raw_server_domain.on('error', function(err) {
    winston.debug("got an exception in raw server, so restarting.");
    return start_raw_server(function() {
      return winston.debug("restarted raw http server");
    });
  });

  start_raw_server = function(cb) {
    return raw_server_domain.run(function() {
      var express, info, project_id, raw_server;
      winston.info("starting raw server...");
      info = INFO;
      winston.debug("info = " + (misc.to_json(info)));
      express = require('express');
      raw_server = express();
      project_id = info.project_id;
      return misc_node.free_port(function(err, port) {
        var base;
        if (err) {
          winston.debug("error starting raw server: " + err);
          cb(err);
          return;
        }
        fs.writeFile(abspath(DATA + "/raw.port"), port, cb);
        base = info.base_url + "/" + project_id + "/raw/";
        winston.info("raw server (port=" + port + "), host='" + info.location.host + "', base='" + base + "'");
        raw_server.configure(function() {
          raw_server.use(base, express.directory(process.env.HOME, {
            hidden: true,
            icons: true
          }));
          return raw_server.use(base, express["static"](process.env.HOME, {
            hidden: true
          }));
        });
        return raw_server.listen(port, info.location.host, function(err) {
          winston.info("err = " + err);
          if (err) {
            cb(err);
            return;
          }
          return fs.writeFile(abspath(DATA + "/raw.port"), port, cb);
        });
      });
    });
  };

  last_activity = void 0;

  activity = function() {
    return last_activity = misc.mswalltime();
  };

  SAGEMATHCLOUD_LOG_THRESH = 5000;

  SAGEMATHCLOUD_LOG_FILE = process.env['HOME'] + '/.sagemathcloud.log';

  log_truncate = function(cb) {
    var data, exists;
    data = void 0;
    winston.info("log_truncate: checking that logfile isn't too long");
    exists = void 0;
    return async.series([
      function(cb) {
        return fs.exists(SAGEMATHCLOUD_LOG_FILE, function(_exists) {
          exists = _exists;
          return cb();
        });
      }, function(cb) {
        if (!exists) {
          cb();
          return;
        }
        return fs.readFile(SAGEMATHCLOUD_LOG_FILE, function(err, _data) {
          data = _data != null ? _data.toString() : void 0;
          return cb(err);
        });
      }, function(cb) {
        var n, new_data, v;
        if (!exists) {
          cb();
          return;
        }
        n = misc.count(data, '\n');
        if (n >= SAGEMATHCLOUD_LOG_THRESH * 1.5) {
          winston.debug("log_truncate: truncating log file to " + SAGEMATHCLOUD_LOG_THRESH + " lines");
          v = data.split('\n');
          new_data = v.slice(n - SAGEMATHCLOUD_LOG_THRESH, v.length - 1).join('\n');
          return fs.writeFile(SAGEMATHCLOUD_LOG_FILE, new_data, cb);
        } else {
          return cb();
        }
      }
    ], cb);
  };

  start_log_truncate = function(cb) {
    var f;
    winston.info("start_log_truncate");
    f = function(c) {
      winston.debug("calling log_truncate");
      return log_truncate(function(err) {
        if (err) {
          winston.debug("ERROR: problem truncating log -- " + err);
        }
        return c();
      });
    };
    setInterval(f, 1000 * 3600 * 12);
    return f(cb);
  };

  exports.start_server = start_server = function() {
    return async.series([start_log_truncate, start_tcp_server, start_raw_server], function(err) {
      if (err) {
        return winston.debug("Error starting a server -- " + err);
      } else {
        return winston.debug("Successfully started servers.");
      }
    });
  };

  program = require('commander');

  daemon = require("start-stop-daemon");

  program.usage('[start/stop/restart/status] [options]').option('--pidfile [string]', 'store pid in this file', String, abspath(DATA + "/local_hub.pid")).option('--logfile [string]', 'write log to this file', String, abspath(DATA + "/local_hub.log")).option('--forever_logfile [string]', 'write forever log to this file', String, abspath(DATA + "/forever_local_hub.log")).option('--debug [string]', 'logging debug level (default: "debug"); "" for no debugging output)', String, 'debug').parse(process.argv);

  if (program._name.split('.')[0] === 'local_hub') {
    if (program.debug) {
      winston.remove(winston.transports.Console);
      winston.add(winston.transports.Console, {
        level: program.debug,
        timestamp: true,
        colorize: true
      });
    }
    winston.debug("Running as a Daemon");
    process.addListener("uncaughtException", function(err) {
      winston.debug("BUG ****************************************************************************");
      winston.debug("Uncaught exception: " + err);
      winston.debug(err.stack);
      winston.debug("BUG ****************************************************************************");
      if ((typeof console !== "undefined" && console !== null) && (console.trace != null)) {
        return console.trace();
      }
    });
    console.log("setting up conf path");
    init_confpath();
    init_info_json();
    fs.writeFileSync(program.forever_logfile, '');
    console.log("start daemon");
    daemon({
      pidFile: program.pidfile,
      outFile: program.logfile,
      errFile: program.logfile,
      logFile: program.forever_logfile,
      max: 1
    }, start_server);
    console.log("after daemon");
  }

}).call(this);
