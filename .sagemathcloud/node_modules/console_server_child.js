// Generated by CoffeeScript 1.9.3
(function() {
  var defaults, message, pty, ref, required, setrlimit;

  pty = require('pty.js');

  message = require('message');

  ref = require('misc'), defaults = ref.defaults, required = ref.required;

  setrlimit = require('posix').setrlimit;

  process.on('message', function(opts, socket) {
    var CSI, CSI_code, misc, parse_resize, resize_sequence, term, term_opts;
    opts = defaults(opts, {
      rows: required,
      cols: required,
      command: required,
      args: required,
      path: void 0
    });
    term_opts = {
      name: 'xterm',
      rows: opts.rows,
      cols: opts.cols
    };
    if (opts.path != null) {
      term_opts.cwd = opts.path;
    }
    if (opts.home != null) {
      term_opts.home = opts.home;
    }
    misc = require('misc');
    term = pty.fork(opts.command, opts.args, term_opts);
    CSI = String.fromCharCode(0x9b);
    resize_sequence = void 0;
    parse_resize = function(data) {
      var cols, i, j, rows, s;
      i = data.indexOf('t');
      if (i === -1) {
        resize_sequence += data;
        return data.length;
      } else {
        s = (resize_sequence + data.slice(0, i)).slice(3);
        resize_sequence = void 0;
        j = s.indexOf(';');
        if (j !== -1) {
          rows = parseInt(s.slice(0, j));
          cols = parseInt(s.slice(j + 1));
          term.resize(cols, rows);
        }
        return i + 1;
      }
    };
    CSI_code = function(data) {
      var end, i, s, start;
      s = data.toString('ascii');
      if (resize_sequence != null) {
        start = 0;
        end = parse_resize(s);
      } else {
        i = s.lastIndexOf(CSI);
        if (i !== -1) {
          resize_sequence = '';
          start = i;
          end = start + parse_resize(s.slice(i));
        }
      }
      if (start != null) {
        data = data.slice(0, start) + data.slice(end + 1);
      }
      return data;
    };
    socket.on('data', function(data) {
      data = CSI_code(data);
      return term.write(data);
    });
    term.on('data', function(data) {
      return socket.write(data);
    });
    term.on('exit', function() {
      return socket.end();
    });
    return socket.on('end', function() {
      return process.exit(1);
    });
  });

}).call(this);
