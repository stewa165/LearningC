// Generated by CoffeeScript 1.9.2
(function() {
  var ActivityLog, RetryUntilSuccess, censor, date_parser, defaults, filename_extension_re, mathjax_delim, reISO, required, timestamp_cmp0, underscore, zipcode,
    slice = [].slice,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  underscore = require('underscore');

  global.RUNNING_IN_NODE = typeof process === 'object' && process + '' === '[object process]';

  global.DEBUG = !global.RUNNING_IN_NODE;

  global.DEBUG = false;

  global.console.debug = function(msg) {
    if (global.DEBUG) {
      return console.log(msg);
    }
  };

  exports.startswith = function(s, x) {
    var l, len1, v;
    if (typeof x === "string") {
      return s.indexOf(x) === 0;
    } else {
      for (l = 0, len1 = x.length; l < len1; l++) {
        v = x[l];
        if (s.indexOf(v) === 0) {
          return true;
        }
      }
      return false;
    }
  };

  exports.endswith = function(s, t) {
    return s.slice(s.length - t.length) === t;
  };

  exports.merge = function() {
    var dest, k, l, len1, obj, objs, v;
    dest = arguments[0], objs = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    for (l = 0, len1 = objs.length; l < len1; l++) {
      obj = objs[l];
      for (k in obj) {
        v = obj[k];
        dest[k] = v;
      }
    }
    return dest;
  };

  exports.random_choice = function(array) {
    return array[Math.floor(Math.random() * array.length)];
  };

  exports.random_choice_from_obj = function(obj) {
    var k;
    k = exports.random_choice(exports.keys(obj));
    return [k, obj[k]];
  };

  exports.randint = function(lower, upper) {
    if (lower > upper) {
      throw new Error("randint: lower is larger than upper");
    }
    return Math.floor(Math.random() * (upper - lower + 1)) + lower;
  };

  exports.split = function(s) {
    var r;
    r = s.match(/\S+/g);
    if (r) {
      return r;
    } else {
      return [];
    }
  };

  exports.search_split = function(search) {
    var element, i, l, len1, length, terms;
    terms = [];
    search = search.split('"');
    length = search.length;
    for (i = l = 0, len1 = search.length; l < len1; i = ++l) {
      element = search[i];
      element = element.trim();
      if (element.length !== 0) {
        if (i % 2 === 0 || (i === length - 1 && length % 2 === 0)) {
          terms.push.apply(terms, element.split(" "));
        } else {
          terms.push(element);
        }
      }
    }
    return terms;
  };

  exports.search_match = function(s, v) {
    var l, len1, x;
    for (l = 0, len1 = v.length; l < len1; l++) {
      x = v[l];
      if (s.indexOf(x) === -1) {
        return false;
      }
    }
    return true;
  };

  exports.contains = function(word, sub) {
    return word.indexOf(sub) !== -1;
  };

  exports.count = function(str, strsearch) {
    var count, index;
    index = -1;
    count = -1;
    while (true) {
      index = str.indexOf(strsearch, index + 1);
      count++;
      if (index === -1) {
        break;
      }
    }
    return count;
  };

  exports.min_object = function(target, upper_bounds) {
    var prop, results, val;
    if (target == null) {
      target = {};
    }
    results = [];
    for (prop in upper_bounds) {
      val = upper_bounds[prop];
      results.push(target[prop] = target.hasOwnProperty(prop) ? target[prop] = Math.min(target[prop], upper_bounds[prop]) : upper_bounds[prop]);
    }
    return results;
  };

  defaults = exports.defaults = function(obj1, obj2, allow_extra) {
    var err, error, prop, r, val;
    if (obj1 == null) {
      obj1 = {};
    }
    error = function() {
      var s;
      try {
        s = "(obj1=" + (exports.trunc(exports.to_json(obj1), 1024)) + ", obj2=" + (exports.trunc(exports.to_json(obj2), 1024)) + ")";
        console.log(s);
        return s;
      } catch (_error) {
        error = _error;
        return "";
      }
    };
    if (typeof obj1 !== 'object') {
      err = "BUG -- Traceback -- misc.defaults -- TypeError: function takes inputs as an object " + (error());
      console.log(err);
      console.trace();
      if (DEBUG) {
        throw new Error(err);
      } else {
        return obj2;
      }
    }
    r = {};
    for (prop in obj2) {
      val = obj2[prop];
      if (obj1.hasOwnProperty(prop) && (obj1[prop] != null)) {
        if (obj2[prop] === exports.defaults.required && (obj1[prop] == null)) {
          err = "misc.defaults -- TypeError: property '" + prop + "' must be specified: " + (error());
          console.debug(err);
          console.trace();
          if (DEBUG) {
            throw new Error(err);
          }
        }
        r[prop] = obj1[prop];
      } else if (obj2[prop] != null) {
        if (obj2[prop] === exports.defaults.required) {
          err = "misc.defaults -- TypeError: property '" + prop + "' must be specified: " + (error());
          console.debug(err);
          console.trace();
          if (DEBUG) {
            throw new Error(err);
          }
        } else {
          r[prop] = obj2[prop];
        }
      }
    }
    if (!allow_extra) {
      for (prop in obj1) {
        val = obj1[prop];
        if (!obj2.hasOwnProperty(prop)) {
          err = "misc.defaults -- TypeError: got an unexpected argument '" + prop + "' " + (error());
          console.debug(err);
          console.trace();
          if (DEBUG) {
            throw new Error(err);
          }
        }
      }
    }
    return r;
  };

  required = exports.required = exports.defaults.required = "__!!!!!!this is a required property!!!!!!__";

  exports.mswalltime = function(t) {
    if (t != null) {
      return (new Date()).getTime() - t;
    } else {
      return (new Date()).getTime();
    }
  };

  exports.walltime = function(t) {
    if (t != null) {
      return exports.mswalltime() / 1000.0 - t;
    } else {
      return exports.mswalltime() / 1000.0;
    }
  };

  exports.uuid = function() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
      var r, v;
      r = Math.random() * 16 | 0;
      v = c === 'x' ? r : r & 0x3 | 0x8;
      return v.toString(16);
    });
  };

  exports.is_valid_uuid_string = function(uuid) {
    return typeof uuid === "string" && uuid.length === 36 && /[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}/i.test(uuid);
  };

  zipcode = new RegExp("^\\d{5}(-\\d{4})?$");

  exports.is_valid_zipcode = function(zip) {
    return zipcode.test(zip);
  };

  exports.times_per_second = function(f, max_time, max_loops) {
    var i, t, tm;
    if (max_time == null) {
      max_time = 5;
    }
    if (max_loops == null) {
      max_loops = 1000;
    }
    t = exports.walltime();
    i = 0;
    tm = 0;
    while (true) {
      f();
      tm = exports.walltime() - t;
      i += 1;
      if (tm >= max_time || i >= max_loops) {
        break;
      }
    }
    return Math.ceil(i / tm);
  };

  exports.to_json = function(x) {
    return JSON.stringify(x);
  };

  exports.to_safe_str = function(x) {
    var key, obj, sanitize, value;
    obj = {};
    for (key in x) {
      value = x[key];
      sanitize = false;
      if (key.indexOf("pass") !== -1) {
        sanitize = true;
      } else if (typeof value === 'string' && value.slice(0, 7) === "sha512$") {
        sanitize = true;
      }
      if (sanitize) {
        obj[key] = '(unsafe)';
      } else {
        if (typeof value === "object") {
          value = "[object]";
        } else if (typeof value === "string") {
          value = exports.trunc(value, 250);
        }
        obj[key] = value;
      }
    }
    return x = exports.to_json(obj);
  };

  reISO = /^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}(?:\.\d*))(?:Z|(\+|-)([\d|:]*))?$/;

  date_parser = function(k, v) {
    if (typeof v === 'string' && v.length === 24 && reISO.exec(v)) {
      return new Date(v);
    } else {
      return v;
    }
  };

  exports.from_json = function(x) {
    var err;
    try {
      return JSON.parse(x, date_parser);
    } catch (_error) {
      err = _error;
      console.debug("from_json: error parsing " + x + " (=" + (exports.to_json(x)) + ") from JSON");
      throw err;
    }
  };

  censor = function(censor) {
    var i;
    i = 0;
    return function(key, value) {
      if (i && typeof censor === 'object' && typeof value === 'object' && censor === value) {
        return '[Circular]';
      }
      if (i >= 29) {
        return '[Unknown]';
      }
      ++i;
      return value;
    };
  };

  exports.to_json_circular = function(x) {
    return JSON.stringify(x, censor(x));
  };

  exports.to_iso = function(d) {
    return (new Date(d - d.getTimezoneOffset() * 60 * 1000)).toISOString().slice(0, -5);
  };

  exports.to_iso_path = function(d) {
    return exports.to_iso(d).replace('T', '-').replace(/:/g, '');
  };

  exports.is_empty_object = function(obj) {
    return Object.keys(obj).length === 0;
  };

  exports.len = function(obj) {
    var a;
    a = obj.length;
    if (a != null) {
      return a;
    }
    return Object.keys(obj).length;
  };

  exports.keys = underscore.keys;

  exports.values = underscore.values;

  exports.dict = function(obj) {
    var a, l, len1, x;
    x = {};
    for (l = 0, len1 = obj.length; l < len1; l++) {
      a = obj[l];
      if (a.length !== 2) {
        throw new Error("ValueError: unexpected length of tuple");
      }
      x[a[0]] = a[1];
    }
    return x;
  };

  exports.remove = function(obj, val) {
    var i, l, ref;
    for (i = l = 0, ref = obj.length; 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {
      if (obj[i] === val) {
        obj.splice(i, 1);
        return;
      }
    }
    throw new Error("ValueError -- item not in array");
  };

  exports.pairs_to_obj = function(v) {
    var l, len1, o, x;
    o = {};
    for (l = 0, len1 = v.length; l < len1; l++) {
      x = v[l];
      o[x[0]] = x[1];
    }
    return o;
  };

  exports.obj_to_pairs = function(obj) {
    var results, x, y;
    results = [];
    for (x in obj) {
      y = obj[x];
      results.push([x, y]);
    }
    return results;
  };

  exports.substring_count = function(string, subString, allowOverlapping) {
    var n, pos, step;
    string += "";
    subString += "";
    if (subString.length <= 0) {
      return string.length + 1;
    }
    n = 0;
    pos = 0;
    step = (allowOverlapping ? 1. : subString.length);
    while (true) {
      pos = string.indexOf(subString, pos);
      if (pos >= 0) {
        n++;
        pos += step;
      } else {
        break;
      }
    }
    return n;
  };

  exports.max = function(array) {
    return array.reduce(function(a, b) {
      return Math.max(a, b);
    });
  };

  exports.min = function(array) {
    return array.reduce(function(a, b) {
      return Math.min(a, b);
    });
  };

  filename_extension_re = /(?:\.([^.]+))?$/;

  exports.filename_extension = function(filename) {
    var ref;
    return (ref = filename_extension_re.exec(filename)[1]) != null ? ref : '';
  };

  exports.filename_extension_notilde = function(filename) {
    var ext;
    ext = exports.filename_extension(filename);
    while (ext && ext[ext.length - 1] === '~') {
      ext = ext.slice(0, ext.length - 1);
    }
    return ext;
  };

  exports.copy = function(obj) {
    var r, x, y;
    if ((obj == null) || typeof obj !== 'object') {
      return obj;
    }
    if (exports.is_array(obj)) {
      return obj.slice(0);
    }
    r = {};
    for (x in obj) {
      y = obj[x];
      r[x] = y;
    }
    return r;
  };

  exports.copy_without = function(obj, without) {
    var r, x, y;
    if (typeof without === 'string') {
      without = [without];
    }
    r = {};
    for (x in obj) {
      y = obj[x];
      if (indexOf.call(without, x) < 0) {
        r[x] = y;
      }
    }
    return r;
  };

  exports.copy_with = function(obj, w) {
    var r, x, y;
    if (typeof w === 'string') {
      w = [w];
    }
    r = {};
    for (x in obj) {
      y = obj[x];
      if (indexOf.call(w, x) >= 0) {
        r[x] = y;
      }
    }
    return r;
  };

  exports.deep_copy = function(obj) {
    var flags, key, newInstance;
    if ((obj == null) || typeof obj !== 'object') {
      return obj;
    }
    if (obj instanceof Date) {
      return new Date(obj.getTime());
    }
    if (obj instanceof RegExp) {
      flags = '';
      if (obj.global != null) {
        flags += 'g';
      }
      if (obj.ignoreCase != null) {
        flags += 'i';
      }
      if (obj.multiline != null) {
        flags += 'm';
      }
      if (obj.sticky != null) {
        flags += 'y';
      }
      return new RegExp(obj.source, flags);
    }
    newInstance = new obj.constructor();
    for (key in obj) {
      newInstance[key] = exports.deep_copy(obj[key]);
    }
    return newInstance;
  };

  exports.path_split = function(path) {
    var v;
    v = path.split('/');
    return {
      head: v.slice(0, -1).join('/'),
      tail: v[v.length - 1]
    };
  };

  exports.path_to_file = function(path, file) {
    if (path === '') {
      return file;
    }
    return path + '/' + file;
  };

  exports.meta_file = function(path, ext) {
    var p;
    p = exports.path_split(path);
    path = p.head;
    if (p.head !== '') {
      path += '/';
    }
    return path + "." + p.tail + ".sage-" + ext;
  };

  exports.trunc = function(s, max_length) {
    if (max_length == null) {
      max_length = 1024;
    }
    if (s == null) {
      return s;
    }
    if (s.length > max_length) {
      if (max_length < 3) {
        throw new Error("ValueError: max_length must be >= 3");
      }
      return s.slice(0, max_length - 3) + "...";
    } else {
      return s;
    }
  };

  exports.trunc_middle = function(s, max_length) {
    var n;
    if (max_length == null) {
      max_length = 1024;
    }
    if (s == null) {
      return s;
    }
    if (s.length <= max_length) {
      return s;
    }
    n = Math.floor(max_length / 2);
    return s.slice(0, n - 2 + (max_length % 2 ? 1 : 0)) + '...' + s.slice(s.length - (n - 1));
  };

  exports.trunc_left = function(s, max_length) {
    if (max_length == null) {
      max_length = 1024;
    }
    if (s == null) {
      return s;
    }
    if (s.length > max_length) {
      if (max_length < 3) {
        throw new Error("ValueError: max_length must be >= 3");
      }
      return "..." + s.slice(s.length - max_length + 3);
    } else {
      return s;
    }
  };

  exports.plural = function(number, singular, plural) {
    if (plural == null) {
      plural = singular + "s";
    }
    if (number === 1) {
      return singular;
    } else {
      return plural;
    }
  };

  exports.git_author = function(first_name, last_name, email_address) {
    return first_name + " " + last_name + " <" + email_address + ">";
  };

  exports.canonicalize_email_address = function(email_address) {
    var i, j;
    if (typeof email_address !== 'string') {
      email_address = JSON.stringify(email_address);
    }
    i = email_address.indexOf('+');
    if (i !== -1) {
      j = email_address.indexOf('@');
      if (j !== -1) {
        email_address = email_address.slice(0, i) + email_address.slice(j);
      }
    }
    return email_address.toLowerCase();
  };

  exports.lower_email_address = function(email_address) {
    if (typeof email_address !== 'string') {
      email_address = JSON.stringify(email_address);
    }
    return email_address.toLowerCase();
  };

  exports.parse_user_search = function(query) {
    var l, len1, q, queries, r, x;
    queries = (function() {
      var l, len1, ref, results;
      ref = query.split(',');
      results = [];
      for (l = 0, len1 = ref.length; l < len1; l++) {
        q = ref[l];
        results.push(q.trim().toLowerCase());
      }
      return results;
    })();
    r = {
      string_queries: [],
      email_queries: []
    };
    for (l = 0, len1 = queries.length; l < len1; l++) {
      x = queries[l];
      if (x) {
        if (x.indexOf('@') === -1) {
          r.string_queries.push(x.split(/\s+/g));
        } else {
          r.email_queries.push(x);
        }
      }
    }
    return r;
  };

  exports.delete_trailing_whitespace = function(s) {
    return s.replace(/[^\S\n]+$/gm, "");
  };

  exports.assert = function(condition, mesg) {
    if (!condition) {
      if (typeof mesg === 'string') {
        throw new Error(mesg);
      }
      throw mesg;
    }
  };

  exports.retry_until_success = function(opts) {
    var delta, g, start_time, tries;
    opts = exports.defaults(opts, {
      f: exports.required,
      start_delay: 100,
      max_delay: 20000,
      factor: 1.4,
      max_tries: void 0,
      max_time: void 0,
      log: void 0,
      name: '',
      cb: void 0
    });
    delta = opts.start_delay;
    tries = 0;
    if (opts.max_time != null) {
      start_time = new Date();
    }
    g = function() {
      tries += 1;
      if (opts.log != null) {
        if (opts.max_tries != null) {
          opts.log("retry_until_success(" + opts.name + ") -- try " + tries + "/" + opts.max_tries);
        }
        if (opts.max_time != null) {
          opts.log("retry_until_success(" + opts.name + ") -- try " + tries + " (started " + (new Date() - start_time) + "ms ago; will stop before " + opts.max_time + "ms max time)");
        }
        if ((opts.max_tries == null) && (opts.max_time == null)) {
          opts.log("retry_until_success(" + opts.name + ") -- try " + tries);
        }
      }
      return opts.f(function(err) {
        if (err) {
          if (opts.log != null) {
            opts.log("retry_until_success(" + opts.name + ") -- err=" + err);
          }
          if ((opts.max_tries != null) && opts.max_tries <= tries) {
            if (typeof opts.cb === "function") {
              opts.cb("maximum tries (=" + opts.max_tries + ") exceeded - last error " + err);
            }
            return;
          }
          delta = Math.min(opts.max_delay, opts.factor * delta);
          if ((opts.max_time != null) && (new Date() - start_time) + delta > opts.max_time) {
            if (typeof opts.cb === "function") {
              opts.cb("maximum time (=" + opts.max_time + "ms) exceeded - last error " + err);
            }
            return;
          }
          return setTimeout(g, delta);
        } else {
          return typeof opts.cb === "function" ? opts.cb() : void 0;
        }
      });
    };
    return g();
  };

  exports.retry_until_success_wrapper = function(opts) {
    var _X;
    _X = new RetryUntilSuccess(opts);
    return function(cb) {
      return _X.call(cb);
    };
  };

  RetryUntilSuccess = (function() {
    function RetryUntilSuccess(opts) {
      this.call = bind(this.call, this);
      this.opts = exports.defaults(opts, {
        f: exports.defaults.required,
        start_delay: 100,
        max_delay: 20000,
        exp_factor: 1.4,
        max_tries: void 0,
        max_time: void 0,
        min_interval: 100,
        logname: void 0,
        verbose: false
      });
      if (this.opts.min_interval != null) {
        if (this.opts.start_delay < this.opts.min_interval) {
          this.opts.start_delay = this.opts.min_interval;
        }
      }
      this.f = this.opts.f;
    }

    RetryUntilSuccess.prototype.call = function(cb, retry_delay) {
      var g, start_time, w;
      if (this.opts.logname != null) {
        console.debug(this.opts.logname + "(... " + retry_delay + ")");
      }
      if (this._cb_stack == null) {
        this._cb_stack = [];
      }
      if (cb != null) {
        this._cb_stack.push(cb);
      }
      if (this._calling) {
        return;
      }
      this._calling = true;
      if (retry_delay == null) {
        this.attempts = 0;
      }
      if (this.opts.logname != null) {
        console.debug("actually calling -- " + this.opts.logname + "(... " + retry_delay + ")");
      }
      if (this.opts.max_time != null) {
        start_time = new Date();
      }
      g = (function(_this) {
        return function() {
          if (_this.opts.min_interval != null) {
            _this._last_call_time = exports.mswalltime();
          }
          return _this.f(function(err) {
            var f, results;
            _this.attempts += 1;
            _this._calling = false;
            if (err) {
              if (_this.opts.verbose) {
                console.debug(_this.opts.logname + ": error=" + err);
              }
              if ((_this.opts.max_tries != null) && _this.attempts >= _this.opts.max_tries) {
                while (_this._cb_stack.length > 0) {
                  _this._cb_stack.pop()(err);
                }
                return;
              }
              if (retry_delay == null) {
                retry_delay = _this.opts.start_delay;
              } else {
                retry_delay = Math.min(_this.opts.max_delay, _this.opts.exp_factor * retry_delay);
              }
              if ((_this.opts.max_time != null) && (new Date() - start_time) + retry_delay > _this.opts.max_time) {
                err = "maximum time (=" + _this.opts.max_time + "ms) exceeded - last error " + err;
                while (_this._cb_stack.length > 0) {
                  _this._cb_stack.pop()(err);
                }
                return;
              }
              f = function() {
                return _this.call(void 0, retry_delay);
              };
              return setTimeout(f, retry_delay);
            } else {
              results = [];
              while (_this._cb_stack.length > 0) {
                results.push(_this._cb_stack.pop()());
              }
              return results;
            }
          });
        };
      })(this);
      if ((this._last_call_time == null) || (this.opts.min_interval == null)) {
        return g();
      } else {
        w = exports.mswalltime(this._last_call_time);
        if (w < this.opts.min_interval) {
          return setTimeout(g, this.opts.min_interval - w);
        } else {
          return g();
        }
      }
    };

    return RetryUntilSuccess;

  })();

  exports.eval_until_defined = function(opts) {
    var delay, f, total;
    opts = exports.defaults(opts, {
      code: exports.required,
      start_delay: 100,
      max_time: 10000,
      exp_factor: 1.4,
      cb: exports.required
    });
    delay = void 0;
    total = 0;
    f = function() {
      var result;
      result = eval(opts.code);
      if (result != null) {
        return opts.cb(false, result);
      } else {
        if (delay == null) {
          delay = opts.start_delay;
        } else {
          delay *= opts.exp_factor;
        }
        total += delay;
        if (total > opts.max_time) {
          return opts.cb("failed to eval code within " + opts.max_time);
        } else {
          return setTimeout(f, delay);
        }
      }
    };
    return f();
  };

  exports.async_debounce = function(opts) {
    var call_again, callbacks, cb, f, interval, ref, state;
    opts = defaults(opts, {
      f: required,
      interval: 1500,
      state: required,
      cb: void 0
    });
    f = opts.f, interval = opts.interval, state = opts.state, cb = opts.cb;
    call_again = function() {
      var n;
      n = interval + 1 - (new Date() - state.last);
      return state.timer = setTimeout(((function(_this) {
        return function() {
          delete state.timer;
          return exports.async_debounce({
            f: f,
            interval: interval,
            state: state
          });
        };
      })(this)), n);
    };
    if ((state.last != null) && (new Date() - state.last) <= interval) {
      if (state.next_callbacks == null) {
        state.next_callbacks = [];
      }
      state.next_callbacks.push(cb);
      if (state.timer == null) {
        call_again();
      }
      return;
    }
    state.last = new Date();
    callbacks = exports.copy((ref = state.next_callbacks) != null ? ref : []);
    callbacks.push(cb);
    state.next_callbacks = [];
    return f((function(_this) {
      return function(err) {
        var l, len1, v;
        v = callbacks;
        for (l = 0, len1 = v.length; l < len1; l++) {
          cb = v[l];
          if (typeof cb === "function") {
            cb(err);
          }
        }
        if (state.next_callbacks.length > 0 && (state.timer == null)) {
          return call_again();
        }
      };
    })(this));
  };

  exports.StringCharMapping = (function() {
    function StringCharMapping(opts) {
      var ch, ref, ref1, st;
      if (opts == null) {
        opts = {};
      }
      this.to_array = bind(this.to_array, this);
      this.to_string = bind(this.to_string, this);
      this._find_next_char = bind(this._find_next_char, this);
      opts = exports.defaults(opts, {
        to_char: void 0,
        to_string: void 0
      });
      this._to_char = {};
      this._to_string = {};
      this._next_char = 'A';
      if (opts.to_string != null) {
        ref = opts.to_string;
        for (ch in ref) {
          st = ref[ch];
          this._to_string[ch] = st;
          this._to_char[st] = ch;
        }
      }
      if (opts.to_char != null) {
        ref1 = opts.to_char;
        for (st in ref1) {
          ch = ref1[st];
          this._to_string[ch] = st;
          this._to_char[st] = ch;
        }
      }
      this._find_next_char();
    }

    StringCharMapping.prototype._find_next_char = function() {
      var results;
      results = [];
      while (true) {
        this._next_char = String.fromCharCode(this._next_char.charCodeAt(0) + 1);
        if (this._to_string[this._next_char] == null) {
          break;
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    StringCharMapping.prototype.to_string = function(strings) {
      var a, l, len1, s, t;
      t = '';
      for (l = 0, len1 = strings.length; l < len1; l++) {
        s = strings[l];
        a = this._to_char[s];
        if (a != null) {
          t += a;
        } else {
          t += this._next_char;
          this._to_char[s] = this._next_char;
          this._to_string[this._next_char] = s;
          this._find_next_char();
        }
      }
      return t;
    };

    StringCharMapping.prototype.to_array = function(string) {
      var s;
      return (function() {
        var l, len1, results;
        results = [];
        for (l = 0, len1 = string.length; l < len1; l++) {
          s = string[l];
          results.push(this._to_string[s]);
        }
        return results;
      }).call(this);
    };

    return StringCharMapping;

  })();

  exports.uniquify_string = function(s) {
    var c, l, len1, seen_already, t;
    seen_already = {};
    t = '';
    for (l = 0, len1 = s.length; l < len1; l++) {
      c = s[l];
      if (seen_already[c] == null) {
        t += c;
        seen_already[c] = true;
      }
    }
    return t;
  };


  /* -- not used
  exports.ensure_string_ends_in_newlines = (s, n) ->
      j = s.length-1
      while j >= 0 and j >= s.length-n and s[j] == '\n'
          j -= 1
       * Now either j = -1 or s[j] is not a newline (and it is the first character not a newline from the right).
      console.debug(j)
      k = n - (s.length - (j + 1))
      console.debug(k)
      if k == 0
          return s
      else
          return s + Array(k+1).join('\n')   # see http://stackoverflow.com/questions/1877475/repeat-character-n-times
   */

  exports.PROJECT_GROUPS = ['owner', 'collaborator', 'viewer', 'invited_collaborator', 'invited_viewer'];

  exports.make_valid_name = function(s) {
    return s.replace(/\W/g, '_').toLowerCase();
  };

  exports.parse_bup_timestamp = function(s) {
    var v;
    v = [s.slice(0, 4), s.slice(5, 7), s.slice(8, 10), s.slice(11, 13), s.slice(13, 15), s.slice(15, 17), '0'];
    return new Date(v[1] + "/" + v[2] + "/" + v[0] + " " + v[3] + ":" + v[4] + ":" + v[5] + " UTC");
  };

  exports.matches = function(s, words) {
    var l, len1, word;
    for (l = 0, len1 = words.length; l < len1; l++) {
      word = words[l];
      if (s.indexOf(word) === -1) {
        return false;
      }
    }
    return true;
  };

  exports.hash_string = function(s) {
    var chr, hash, i, len;
    hash = 0;
    i = void 0;
    chr = void 0;
    len = void 0;
    if (s.length === 0) {
      return hash;
    }
    i = 0;
    len = s.length;
    while (i < len) {
      chr = s.charCodeAt(i);
      hash = ((hash << 5) - hash) + chr;
      hash |= 0;
      i++;
    }
    return hash;
  };

  exports.parse_hashtags = function(t) {
    var base, i, v;
    v = [];
    if (t == null) {
      return v;
    }
    base = 0;
    while (true) {
      i = t.indexOf('#');
      if (i === -1 || i === t.length - 1) {
        return v;
      }
      base += i + 1;
      if (t[i + 1] === '#' || !(i === 0 || t[i - 1].match(/\s/))) {
        t = t.slice(i + 1);
        continue;
      }
      t = t.slice(i + 1);
      i = t.match(/\s|[^A-Za-z0-9_\-]/);
      if (i) {
        i = i.index;
      } else {
        i = -1;
      }
      if (i === 0) {
        base += i + 1;
        t = t.slice(i + 1);
      } else {
        if (i === -1) {
          v.push([base - 1, base + t.length]);
          return v;
        } else {
          v.push([base - 1, base + i]);
          base += i + 1;
          t = t.slice(i + 1);
        }
      }
    }
  };

  mathjax_delim = [['$$', '$$'], ['\\(', '\\)'], ['\\[', '\\]'], ['\\begin{equation}', '\\end{equation}'], ['\\begin{equation*}', '\\end{equation*}'], ['\\begin{align}', '\\end{align}'], ['\\begin{align*}', '\\end{align*}'], ['\\begin{eqnarray}', '\\end{eqnarray}'], ['\\begin{eqnarray*}', '\\end{eqnarray*}'], ['$', '$']];

  exports.parse_mathjax = function(t) {
    var d, i, j, l, len1, v;
    v = [];
    if (t == null) {
      return v;
    }
    i = 0;
    while (i < t.length) {
      if (t.slice(i, i + 2) === '\\$') {
        i += 2;
        continue;
      }
      for (l = 0, len1 = mathjax_delim.length; l < len1; l++) {
        d = mathjax_delim[l];
        if (t.slice(i, i + d[0].length) === d[0]) {
          j = i + 1;
          while (j < t.length && t.slice(j, j + d[1].length) !== d[1]) {
            j += 1;
          }
          j += d[1].length;
          v.push([i, j]);
          i = j;
          break;
        }
      }
      i += 1;
    }
    return v;
  };

  exports.mathjax_escape = function(html) {
    return html.replace(/&(?!#?\w+;)/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#39;");
  };

  exports.path_is_in_public_paths = function(path, paths) {
    return exports.containing_public_path(path, paths) != null;
  };

  exports.containing_public_path = function(path, paths) {
    var l, len1, p;
    if (paths.length === 0) {
      return;
    }
    if (path == null) {
      return;
    }
    if (path.indexOf('../') !== -1) {
      return;
    }
    for (l = 0, len1 = paths.length; l < len1; l++) {
      p = paths[l];
      if (p === "") {
        return "";
      }
      if (path === p) {
        return p;
      }
      if (path.slice(0, p.length + 1) === p + '/') {
        return p;
      }
    }
    if (exports.filename_extension(path) === "zip") {
      return exports.containing_public_path(path.slice(0, path.length - 4), paths);
    }
    return void 0;
  };

  exports.encode_path = function(path) {
    path = encodeURI(path);
    return path.replace(/#/g, '%23').replace(/\?/g, '%3F');
  };

  exports.call_lock = function(opts) {
    var obj;
    opts = exports.defaults(opts, {
      obj: exports.required,
      timeout_s: 30
    });
    obj = opts.obj;
    obj._call_lock = function() {
      obj.__call_lock = true;
      obj.__call_lock_timeout = function() {
        obj.__call_lock = false;
        return delete obj.__call_lock_timeout;
      };
      return setTimeout(obj.__call_lock_timeout, opts.timeout_s * 1000);
    };
    obj._call_unlock = function() {
      if (obj.__call_lock_timeout != null) {
        clearTimeout(obj.__call_lock_timeout);
        delete obj.__call_lock_timeout;
      }
      return obj.__call_lock = false;
    };
    return obj._call_with_lock = function(f, cb) {
      if (obj.__call_lock) {
        if (typeof cb === "function") {
          cb("error -- hit call_lock");
        }
        return;
      }
      obj._call_lock();
      return f(function() {
        var args;
        args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        obj._call_unlock();
        return typeof cb === "function" ? cb.apply(null, args) : void 0;
      });
    };
  };

  exports.cmp = function(a, b) {
    if (a < b) {
      return -1;
    } else if (a > b) {
      return 1;
    }
    return 0;
  };

  exports.cmp_array = function(a, b) {
    var c, i, l, ref;
    for (i = l = 0, ref = Math.max(a.length, b.length); 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {
      c = exports.cmp(a[i], b[i]);
      if (c) {
        return c;
      }
    }
    return 0;
  };

  exports.timestamp_cmp = function(a, b) {
    a = a.timestamp;
    b = b.timestamp;
    if (a == null) {
      return 1;
    }
    if (b == null) {
      return -1;
    }
    if (a > b) {
      return -1;
    } else if (a < b) {
      return +1;
    }
    return 0;
  };

  timestamp_cmp0 = function(a, b) {
    a = a.timestamp;
    b = b.timestamp;
    if (a == null) {
      return -1;
    }
    if (b == null) {
      return 1;
    }
    if (a < b) {
      return -1;
    } else if (a > b) {
      return +1;
    }
    return 0;
  };

  ActivityLog = (function() {
    function ActivityLog(opts) {
      this._process_event = bind(this._process_event, this);
      this.process = bind(this.process, this);
      this.path = bind(this.path, this);
      this.obj = bind(this.obj, this);
      opts = exports.defaults(opts, {
        events: void 0,
        account_id: exports.required,
        notifications: {}
      });
      this.notifications = opts.notifications;
      this.account_id = opts.account_id;
      if (opts.events != null) {
        this.process(opts.events);
      }
    }

    ActivityLog.prototype.obj = function() {
      return {
        notifications: this.notifications,
        account_id: this.account_id
      };
    };

    ActivityLog.prototype.path = function(e) {
      return e.project_id + "/" + e.path;
    };

    ActivityLog.prototype.process = function(events) {
      var by_path, e, event, events_with_path, key, l, len1, path, results;
      by_path = {};
      for (l = 0, len1 = events.length; l < len1; l++) {
        e = events[l];
        key = this.path(e);
        events_with_path = by_path[key];
        if (events_with_path == null) {
          events_with_path = by_path[key] = [e];
        } else {
          events_with_path.push(e);
        }
      }
      results = [];
      for (path in by_path) {
        events_with_path = by_path[path];
        events_with_path.sort(timestamp_cmp0);
        results.push((function() {
          var len2, results1, u;
          results1 = [];
          for (u = 0, len2 = events_with_path.length; u < len2; u++) {
            event = events_with_path[u];
            results1.push(this._process_event(event, path));
          }
          return results1;
        }).call(this));
      }
      return results;
    };

    ActivityLog.prototype._process_event = function(event, path) {
      var a, who;
      if (path == null) {
        path = this.path(event);
      }
      a = this.notifications[path];
      if (a == null) {
        this.notifications[path] = a = {};
      }
      a.timestamp = event.timestamp;
      a.id = event.id;
      if ((event.seen_by != null) && event.seen_by.indexOf(this.account_id) !== -1) {
        a.seen = event.timestamp;
      }
      if ((event.read_by != null) && event.read_by.indexOf(this.account_id) !== -1) {
        a.read = event.timestamp;
      }
      if (event.action != null) {
        who = a[event.action];
        if (who == null) {
          who = a[event.action] = {};
        }
        return who[event.account_id] = event.timestamp;
      }
    };

    return ActivityLog;

  })();

  exports.activity_log = function(opts) {
    return new ActivityLog(opts);
  };

  exports.replace_all = function(string, search, replace) {
    return string.split(search).join(replace);
  };

  exports.remove_c_comments = function(s) {
    var i, j;
    while (true) {
      i = s.indexOf('/*');
      if (i === -1) {
        return s;
      }
      j = s.indexOf('*/');
      if (i >= j) {
        return s;
      }
      s = s.slice(0, i) + s.slice(j + 2);
    }
  };

  exports.date_to_snapshot_format = function(d) {
    var i, s;
    if (d == null) {
      d = 0;
    }
    if (typeof d === "number") {
      d = new Date(d);
    }
    s = d.toJSON();
    s = s.replace('T', '-').replace(/:/g, '');
    i = s.lastIndexOf('.');
    return s.slice(0, i);
  };

  exports.stripe_date = function(d) {
    return new Date(d * 1000).toLocaleDateString('lookup', {
      year: 'numeric',
      month: 'long',
      day: 'numeric'
    });
  };

  exports.to_money = function(n) {
    return n.toFixed(2).replace(/(\d)(?=(\d{3})+\.)/g, '$1,');
  };

  exports.stripe_amount = function(units, currency) {
    if (currency !== 'usd') {
      throw Error("not-implemented currency " + currency);
    }
    return "$" + (exports.to_money(units / 100));
  };

  exports.capitalize = function(s) {
    if (s != null) {
      return s.charAt(0).toUpperCase() + s.slice(1);
    }
  };

  exports.is_array = function(obj) {
    return Object.prototype.toString.call(obj) === "[object Array]";
  };

  exports.get_array_range = function(arr, value1, value2) {
    var index1, index2, ref;
    index1 = arr.indexOf(value1);
    index2 = arr.indexOf(value2);
    if (index1 > index2) {
      ref = [index2, index1], index1 = ref[0], index2 = ref[1];
    }
    return arr.slice(index1, +index2 + 1 || 9e9);
  };

  exports.milliseconds_ago = function(ms) {
    return new Date(new Date() - ms);
  };

  exports.seconds_ago = function(s) {
    return exports.milliseconds_ago(1000 * s);
  };

  exports.minutes_ago = function(m) {
    return exports.seconds_ago(60 * m);
  };

  exports.hours_ago = function(h) {
    return exports.minutes_ago(60 * h);
  };

  exports.days_ago = function(d) {
    return exports.hours_ago(24 * d);
  };

}).call(this);
