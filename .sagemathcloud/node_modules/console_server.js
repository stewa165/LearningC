// Generated by CoffeeScript 1.9.3
(function() {
  var DATA, abspath, assert, async, child_process, daemon, defaults, fname, from_json, fs, handle_client, local_hub, message, misc_node, net, program, read_token, ref, required, secret_token, server, start_server, start_session, to_json, winston;

  async = require('async');

  fs = require('fs');

  net = require('net');

  child_process = require('child_process');

  message = require('message');

  misc_node = require('misc_node');

  winston = require('winston');

  local_hub = require('local_hub');

  ref = require('misc'), to_json = ref.to_json, from_json = ref.from_json, defaults = ref.defaults, required = ref.required;

  assert = require('assert');

  abspath = function(path) {
    if (path.length === 0) {
      return process.env.HOME;
    }
    if (path[0] === '/') {
      return path;
    }
    return process.env.HOME + '/' + path;
  };

  DATA = process.env['SAGEMATHCLOUD'] + '/data';

  fname = local_hub.secret_token_filename;

  secret_token = void 0;

  read_token = function() {
    return fs.exists(fname, function(exists) {
      var e;
      if (exists) {
        try {
          secret_token = fs.readFileSync(fname).toString();
          return winston.debug("Read the secret_token file.");
        } catch (_error) {
          e = _error;
          return setTimeout(read_token, 250);
        }
      } else {
        return setTimeout(read_token, 250);
      }
    });
  };

  start_session = function(socket, mesg) {
    var opts;
    winston.info("start_session " + (to_json(mesg)));
    if (mesg.params == null) {
      mesg.params = {};
    }
    opts = defaults(mesg.params, {
      rows: 24,
      cols: 80,
      command: 'bash',
      args: [],
      path: void 0
    });
    if (process.env['USER'] === 'root') {
      if ((mesg.project_id == null) || mesg.project_id.length !== 36) {
        winston.debug("suspicious project_id (=" + mesg.project_id + ") -- bailing");
        return;
      }
    }
    winston.debug("start_session opts = " + (to_json(opts)));
    return async.series([
      function(cb) {
        var child;
        child = child_process.fork(__dirname + '/console_server_child.js', []);
        socket.write_mesg('json', message.session_description({
          pid: child.pid
        }));
        misc_node.disable_mesg(socket);
        child.send(opts, socket);
        return cb();
      }
    ], function(err) {
      if (err) {
        return winston.debug("ERROR - " + err);
      }
    });
  };

  handle_client = function(socket, mesg) {
    var e, err, signal;
    try {
      switch (mesg.event) {
        case 'start_session':
        case 'connect_to_session':
          return start_session(socket, mesg);
        case 'send_signal':
          switch (mesg.signal) {
            case 2:
              signal = 'SIGINT';
              break;
            case 3:
              signal = 'SIGQUIT';
              break;
            case 9:
              signal = 'SIGKILL';
              break;
            default:
              throw "only signals 2 (SIGINT), 3 (SIGQUIT), and 9 (SIGKILL) are supported";
          }
          process.kill(mesg.pid, signal);
          if (mesg.id != null) {
            return socket.write_mesg('json', message.signal_sent({
              id: mesg.id
            }));
          }
          break;
        default:
          if (mesg.id != null) {
            err = message.error({
              id: mesg.id,
              error: "Console server received an invalid mesg type '" + mesg.event + "'"
            });
          }
          return socket.write_mesg('json', err);
      }
    } catch (_error) {
      e = _error;
      return winston.error("ERROR: '" + e + "' handling message '" + (to_json(mesg)) + "'");
    }
  };

  server = net.createServer(function(socket) {
    winston.debug("PARENT: received connection");
    if (secret_token == null) {
      winston.debug("ignoring incoming connection, since we do not have the secret_token yet.");
      socket.write('n');
      socket.write("Unable to accept connection, since console server doesn't yet know the secret token.");
      socket.end();
      return;
    }
    return misc_node.unlock_socket(socket, secret_token, function(err) {
      if (!err) {
        misc_node.enable_mesg(socket);
        return socket.on('mesg', function(type, mesg) {
          winston.debug("received control mesg " + (to_json(mesg)));
          return handle_client(socket, mesg);
        });
      }
    });
  });

  exports.start_server = start_server = function() {
    read_token();
    return server.listen(program.port, program.host, function() {
      winston.info("listening on port " + (server.address().port));
      return fs.writeFile(abspath(DATA + "/console_server.port"), server.address().port);
    });
  };

  program = require('commander');

  daemon = require("start-stop-daemon");

  program.usage('[start/stop/restart/status] [options]').option('-p, --port <n>', 'port to listen on (default: 0 = automatically allocated; saved to $SAGEMATHCLOUD/data/console_server.port)', parseInt, 0).option('--pidfile [string]', 'store pid in this file (default: "$SAGEMATHCLOUD/data/console_server.pid")', String, abspath(DATA + "/console_server.pid")).option('--logfile [string]', 'write log to this file (default: "$SAGEMATHCLOUD/data/console_server.log")', String, abspath(DATA + "/console_server.log")).option('--forever_logfile [string]', 'write forever log to this file', String, abspath(DATA + "/forever_console_server.log")).option('--host [string]', 'bind to this interface (default: 127.0.0.1)', String, "127.0.0.1").parse(process.argv);

  if (program._name.split('.')[0] === 'console_server') {
    process.addListener("uncaughtException", function(err) {
      winston.debug("BUG ****************************************************************************");
      winston.debug("Uncaught exception: " + err);
      winston.debug(err.stack);
      winston.debug("BUG ****************************************************************************");
      winston.error("Uncaught exception: " + err);
      if ((typeof console !== "undefined" && console !== null) && (console.trace != null)) {
        return console.trace();
      }
    });
    daemon({
      pidFile: program.pidfile,
      outFile: program.logfile,
      errFile: program.logfile,
      logFile: program.forever_logfile,
      max: 1
    }, start_server);
  }

}).call(this);
