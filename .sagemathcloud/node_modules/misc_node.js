// Generated by CoffeeScript 1.9.2
(function() {
  var abspath, address_to_local_port, assert, async, child_process, crypto, defaults, enable_mesg, ensure_containing_directory_exists, execute_code, free_port, fs, local_port_to_child_process, message, misc, net, required, temp, to_json, walltime, winston,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  assert = require('assert');

  winston = require('winston');

  net = require('net');

  fs = require('fs');

  misc = require('misc');

  async = require('async');

  walltime = misc.walltime, defaults = misc.defaults, required = misc.required, to_json = misc.to_json;


  /*
  Asynchronous JSON functionality: these are slower but block the main thread *less*.
  
  - to_json_async - convert object to JSON string without blocking.
    This uses https://github.com/ckknight/async-json
  
  - from_json_async - convert JSON string to object/etc., without blocking,
    though 2x times as slow as JSON.parse.  This uses https://github.com/bjouhier/i-json
  
  TESTS:
  
  m=require('misc_node');s=JSON.stringify({x:new Buffer(10000000).toString('hex')}); d=new Date(); m.from_json_async(string: s, chunk_size:10000, cb: (e, r) -> console.log(e, new Date() - d)); new Date() - d
   */


  /*
  exports.to_json_async = (opts) ->
      opts = defaults opts,
          obj        : required    # Javascript object to convert to a JSON string
          cb         : required    # cb(err, JSON string)
  
  ijson = require('i-json')
  exports.from_json_async = (opts) ->
      opts = defaults opts,
          string     : required   # string in JSON format
          chunk_size : 50000      # size of chunks to parse -- affects how long this blocks the main thread
          cb         : required
      p = ijson.createParser()
      s = opts.string
      f = (i, cb) ->
          #t = misc.mswalltime()
          p.update(s.slice(i*opts.chunk_size, (i+1)*opts.chunk_size))
          #console.log("update: #{misc.mswalltime(t)}")
          setTimeout(cb, 0)
      async.mapSeries [0...s.length/opts.chunk_size], f, (err) ->
          opts.cb(err, p.result())
   */

  message = require('message');

  exports.enable_mesg = enable_mesg = function(socket, desc) {
    socket.setMaxListeners(500);
    socket._buf = null;
    socket._buf_target_length = -1;
    socket._listen_for_mesg = function(data) {
      var e, mesg, obj, s, type;
      socket._buf = socket._buf === null ? data : Buffer.concat([socket._buf, data]);
      while (true) {
        if (socket._buf_target_length === -1) {
          if (socket._buf.length >= 4) {
            socket._buf_target_length = socket._buf.readUInt32BE(0) + 4;
          } else {
            return;
          }
        }
        if (socket._buf_target_length <= socket._buf.length) {
          type = socket._buf.slice(4, 5).toString();
          mesg = socket._buf.slice(5, socket._buf_target_length);
          switch (type) {
            case 'j':
              s = mesg.toString();
              try {
                obj = JSON.parse(s);
              } catch (_error) {
                e = _error;
                winston.debug("Error parsing JSON message='" + (misc.trunc(s, 512)) + "' on socket " + desc);
                return;
              }
              socket.emit('mesg', 'json', obj);
              break;
            case 'b':
              socket.emit('mesg', 'blob', {
                uuid: mesg.slice(0, 36).toString(),
                blob: mesg.slice(36)
              });
              break;
            default:
              throw "unknown message type '" + type + "'";
          }
          socket._buf = socket._buf.slice(socket._buf_target_length);
          socket._buf_target_length = -1;
          if (socket._buf.length === 0) {
            return;
          }
        } else {
          return;
        }
      }
    };
    socket.on('data', socket._listen_for_mesg);
    socket.write_mesg = function(type, data, cb) {
      var send;
      send = function(s) {
        var buf;
        buf = new Buffer(4);
        if (typeof s === "string") {
          s = Buffer(s);
        }
        buf.writeInt32BE(s.length, 0);
        if (!socket.writable) {
          if (typeof cb === "function") {
            cb("socket not writable");
          }
          return;
        } else {
          socket.write(buf);
        }
        if (!socket.writable) {
          if (typeof cb === "function") {
            cb("socket not writable");
          }
        } else {
          return socket.write(s, cb);
        }
      };
      switch (type) {
        case 'json':
          return send('j' + JSON.stringify(data));
        case 'blob':
          assert(data.uuid != null, "data object *must* have a uuid attribute");
          assert(data.blob != null, "data object *must* have a blob attribute");
          return send(Buffer.concat([new Buffer('b'), new Buffer(data.uuid), new Buffer(data.blob)]));
        default:
          return cb("unknown message type '" + type + "'");
      }
    };
    return socket.recv_mesg = function(opts) {
      var f, timeout;
      opts = defaults(opts, {
        type: required,
        id: required,
        cb: required,
        timeout: void 0
      });
      f = function(type, mesg) {
        if (type === opts.type && ((type === 'json' && mesg.id === opts.id) || (type === 'blob' && (mesg.uuid = opts.id)))) {
          socket.removeListener('mesg', f);
          return opts.cb(mesg);
        }
      };
      socket.on('mesg', f);
      if (opts.timeout != null) {
        timeout = function() {
          if ((socket != null) && indexOf.call(socket.listeners('mesg'), f) >= 0) {
            socket.removeListener('mesg', f);
            return opts.cb(message.error({
              error: "Timed out after " + opts.timeout + " seconds."
            }));
          }
        };
        return setTimeout(timeout, opts.timeout * 1000);
      }
    };
  };

  exports.disable_mesg = function(socket) {
    if (socket._listen_for_mesg != null) {
      socket.removeListener('data', socket._listen_for_mesg);
      return delete socket._listen_for_mesg;
    }
  };

  exports.unlock_socket = function(socket, token, cb) {
    var listener, timeout, user_token;
    timeout = setTimeout((function() {
      socket.destroy();
      return cb("Unlock socket -- timed out waiting for secret token");
    }), 10000);
    user_token = '';
    listener = function(data) {
      user_token += data.toString();
      if (user_token === token) {
        socket.removeListener('data', listener);
        socket.write('y');
        clearTimeout(timeout);
        return cb(false);
      } else if (user_token.length > token.length || token.slice(0, user_token.length) !== user_token) {
        socket.removeListener('data', listener);
        socket.write('n');
        socket.write("Invalid secret token.");
        socket.destroy();
        clearTimeout(timeout);
        return cb("Invalid secret token.");
      }
    };
    return socket.on('data', listener);
  };

  exports.connect_to_locked_socket = function(opts) {
    var cb, host, port, ref, socket, timed_out, timeout, timer, token;
    ref = defaults(opts, {
      host: 'localhost',
      port: required,
      token: required,
      timeout: 5,
      cb: required
    }), port = ref.port, host = ref.host, token = ref.token, timeout = ref.timeout, cb = ref.cb;
    if (!(port > 0 && port < 65536)) {
      cb("connect_to_locked_socket -- RangeError: port should be > 0 and < 65536: " + port);
      return;
    }
    winston.debug("misc_node: connecting to a locked socket on port " + port + "...");
    timer = void 0;
    timed_out = function() {
      var m;
      m = "misc_node: timed out trying to connect to locked socket on port " + port;
      winston.debug(m);
      if (typeof cb === "function") {
        cb(m);
      }
      cb = void 0;
      if (typeof socket !== "undefined" && socket !== null) {
        socket.end();
      }
      return timer = void 0;
    };
    timer = setTimeout(timed_out, timeout * 1000);
    socket = net.connect({
      host: host,
      port: port
    }, (function(_this) {
      return function() {
        var listener;
        listener = function(data) {
          winston.debug("misc_node: got back response: " + data);
          socket.removeListener('data', listener);
          if (data.toString() === 'y') {
            if (timer != null) {
              clearTimeout(timer);
              if (typeof cb === "function") {
                cb(void 0, socket);
              }
              return cb = void 0;
            }
          } else {
            socket.destroy();
            if (timer != null) {
              clearTimeout(timer);
              if (typeof cb === "function") {
                cb("Permission denied (invalid secret token) when connecting to the local hub.");
              }
              return cb = void 0;
            }
          }
        };
        socket.on('data', listener);
        winston.debug("misc_node: connected, now sending secret token");
        return socket.write(token);
      };
    })(this));
    return socket.on("error", (function(_this) {
      return function(err) {
        if (timer != null) {
          clearTimeout(timer);
        }
        if (typeof cb === "function") {
          cb(err);
        }
        return cb = void 0;
      };
    })(this));
  };

  crypto = require('crypto');

  exports.sha1 = function(data) {
    var sha1sum;
    sha1sum = crypto.createHash('sha1');
    sha1sum.update(data);
    return sha1sum.digest('hex');
  };

  exports.uuidsha1 = function(data) {
    var i, s;
    s = exports.sha1(data);
    i = -1;
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
      i += 1;
      switch (c) {
        case 'x':
          return s[i];
        case 'y':
          return ((parseInt('0x' + s[i], 16) & 0x3) | 0x8).toString(16);
      }
    });
  };

  temp = require('temp');

  async = require('async');

  fs = require('fs');

  child_process = require('child_process');

  exports.execute_code = execute_code = function(opts) {
    var env, exit_code, k, ran_code, ref, s, start_time, stderr, stdout, tmpfilename, v;
    opts = defaults(opts, {
      command: required,
      args: [],
      path: void 0,
      timeout: 10,
      ulimit_timeout: true,
      err_on_exit: true,
      max_output: void 0,
      bash: false,
      home: void 0,
      uid: void 0,
      gid: void 0,
      env: void 0,
      verbose: true,
      cb: void 0
    });
    start_time = walltime();
    if (opts.verbose) {
      winston.debug("execute_code: \"" + opts.command + " " + (opts.args.join(' ')) + "\"");
    }
    s = opts.command.split(/\s+/g);
    if (opts.args.length === 0 && s.length > 1) {
      opts.bash = true;
    }
    if (opts.home == null) {
      opts.home = process.env.HOME;
    }
    if (opts.path == null) {
      opts.path = opts.home;
    } else if (opts.path[0] !== '/') {
      opts.path = opts.home + '/' + opts.path;
    }
    stdout = '';
    stderr = '';
    exit_code = void 0;
    env = misc.copy(process.env);
    if (opts.env != null) {
      ref = opts.env;
      for (k in ref) {
        v = ref[k];
        env[k] = v;
      }
    }
    if (opts.uid != null) {
      env.HOME = opts.home;
    }
    tmpfilename = void 0;
    ran_code = false;
    return async.series([
      function(c) {
        var cmd;
        if (!opts.bash) {
          c();
          return;
        }
        if ((opts.timeout != null) && opts.ulimit_timeout) {
          cmd = "ulimit -t " + opts.timeout + "\n" + opts.command;
        } else {
          cmd = opts.command;
        }
        if (opts.verbose) {
          winston.debug("execute_code: writing temporary file that contains bash program.");
        }
        return temp.open('', function(err, info) {
          if (err) {
            return c(err);
          } else {
            opts.command = 'bash';
            opts.args = [info.path];
            tmpfilename = info.path;
            fs.write(info.fd, cmd);
            return fs.close(info.fd, c);
          }
        });
      }, function(c) {
        if (tmpfilename != null) {
          return fs.chmod(tmpfilename, 0x1ff, c);
        } else {
          return c();
        }
      }, function(c) {
        var callback_done, e, f, finish, o, r, stderr_is_done, stdout_is_done;
        if (opts.verbose) {
          winston.debug("Spawning the command " + opts.command + " with given args " + opts.args + " and timeout of " + opts.timeout + "s...");
        }
        o = {
          cwd: opts.path
        };
        if (env != null) {
          o.env = env;
        }
        if (opts.uid) {
          o.uid = opts.uid;
        }
        if (opts.gid) {
          o.gid = opts.gid;
        }
        try {
          r = child_process.spawn(opts.command, opts.args, o);
        } catch (_error) {
          e = _error;
          c("error " + (misc.to_json(e)));
          return;
        }
        ran_code = true;
        if (opts.verbose) {
          winston.debug("Listen for stdout, stderr and exit events.");
        }
        stdout = '';
        r.stdout.on('data', function(data) {
          data = data.toString();
          if (opts.max_output != null) {
            if (stdout.length < opts.max_output) {
              return stdout += data.slice(0, opts.max_output - stdout.length);
            }
          } else {
            return stdout += data;
          }
        });
        r.stderr.on('data', function(data) {
          data = data.toString();
          if (opts.max_output != null) {
            if (stderr.length < opts.max_output) {
              return stderr += data.slice(0, opts.max_output - stderr.length);
            }
          } else {
            return stderr += data;
          }
        });
        stderr_is_done = stdout_is_done = false;
        r.stderr.on('end', function() {
          stderr_is_done = true;
          return finish();
        });
        r.stdout.on('end', function() {
          stdout_is_done = true;
          return finish();
        });
        r.on('exit', function(code) {
          exit_code = code;
          return finish();
        });
        r.on('error', function(err) {
          if (exit_code == null) {
            exit_code = 1;
          }
          stderr += to_json(err);
          return finish();
        });
        callback_done = false;
        finish = function() {
          if (stdout_is_done && stderr_is_done && (exit_code != null)) {
            if (opts.err_on_exit && exit_code !== 0) {
              if (!callback_done) {
                callback_done = true;
                return c("command '" + opts.command + "' (args=" + (opts.args.join(' ')) + ") exited with nonzero code " + exit_code + " -- stderr='" + stderr + "'");
              }
            } else {
              if (opts.max_output != null) {
                if (stdout.length >= opts.max_output) {
                  stdout += " (truncated at " + opts.max_output + " characters)";
                }
                if (stderr.length >= opts.max_output) {
                  stderr += " (truncated at " + opts.max_output + " characters)";
                }
              }
              if (!callback_done) {
                callback_done = true;
                return c();
              }
            }
          }
        };
        if (opts.timeout != null) {
          f = function() {
            if (r.exitCode === null) {
              if (opts.verbose) {
                winston.debug("execute_code: subprocess did not exit after " + opts.timeout + " seconds, so killing with SIGKILL");
              }
              try {
                r.kill("SIGKILL");
              } catch (_error) {
                e = _error;
              }
              if (opts.verbose) {
                winston.debug("execute_code: r.kill raised an exception.");
              }
              if (!callback_done) {
                callback_done = true;
                return c("killed command '" + opts.command + " " + (opts.args.join(' ')) + "'");
              }
            }
          };
          return setTimeout(f, opts.timeout * 1000);
        }
      }
    ], function(err) {
      var e;
      if (exit_code == null) {
        exit_code = 1;
      }
      if (tmpfilename != null) {
        try {
          fs.unlink(tmpfilename);
        } catch (_error) {
          e = _error;
          winston.debug("failed to unlink " + tmpfilename);
        }
      }
      if (opts.verbose) {
        winston.debug("finished exec of " + opts.command + " (took " + (walltime(start_time)) + "s)");
        winston.debug("stdout='" + (misc.trunc(stdout, 512)) + "', stderr='" + (misc.trunc(stderr, 512)) + "', exit_code=" + exit_code);
      }
      if (!opts.err_on_exit && ran_code) {
        return typeof opts.cb === "function" ? opts.cb(false, {
          stdout: stdout,
          stderr: stderr,
          exit_code: exit_code
        }) : void 0;
      } else {
        return typeof opts.cb === "function" ? opts.cb(err, {
          stdout: stdout,
          stderr: stderr,
          exit_code: exit_code
        }) : void 0;
      }
    });
  };

  exports.disk_usage = function(path, cb) {
    return exports.execute_code({
      command: "du",
      args: ['-s', path],
      cb: function(err, output) {
        if (err) {
          return cb(err);
        } else {
          return cb(false, parseInt(output.stdout.split(' ')[0]));
        }
      }
    });
  };

  exports.username = function(project_id) {
    if (indexOf.call(project_id, '..') >= 0 || project_id.length !== 36) {
      throw Error("invalid project id " + project_id);
    }
    return project_id.slice(0, 8).replace(/[^a-z0-9]/g, '');
  };

  address_to_local_port = {};

  local_port_to_child_process = {};

  exports.keep_portforward_alive = function(port) {
    var r;
    r = local_port_to_child_process[port];
    if (r != null) {
      return r.activity = true;
    }
  };

  exports.unforward_port = function(opts) {
    var r;
    opts = defaults(opts, {
      port: required,
      cb: required
    });
    winston.debug("Unforwarding port " + opts.port);
    r = local_port_to_child_process[local_port];
    if (r != null) {
      return r.kill("SIGKILL");
    }
  };

  exports.unforward_all_ports = function() {
    var port, r, results;
    results = [];
    for (port in local_port_to_child_process) {
      r = local_port_to_child_process[port];
      results.push(r.kill("SIGKILL"));
    }
    return results;
  };

  free_port = exports.free_port = function(cb) {
    var port, server;
    server = require("net").createServer();
    port = 0;
    server.on("listening", function() {
      port = server.address().port;
      return server.close();
    });
    server.on("close", function() {
      var f;
      f = function() {
        return cb(null, port);
      };
      return setTimeout(f, 500);
    });
    return server.listen(0);
  };

  exports.forward_remote_port_to_localhost = function(opts) {
    var remote_address;
    opts = defaults(opts, {
      username: required,
      host: required,
      ssh_port: 22,
      remote_port: required,
      activity_time: 2000,
      keep_alive_time: 2000,
      cb: required
    });
    opts.ssh_port = parseInt(opts.ssh_port);
    if (!(opts.ssh_port >= 1 && opts.ssh_port <= 66000)) {
      opts.cb("Invalid ssh_port option");
      return;
    }
    opts.remote_port = parseInt(opts.remote_port);
    if (!(opts.remote_port >= 1 && opts.remote_port <= 66000)) {
      opts.cb("Invalid remote_port option");
      return;
    }
    winston.debug("Forward a remote port " + opts.remote_port + " on " + opts.host + " to localhost.");
    remote_address = opts.username + "@" + opts.host + ":" + opts.remote_port + " -p" + opts.ssh_port;

    /*
    local_port = address_to_local_port[remote_address]
    if local_port?
         * We already have a valid forward
        opts.cb(false, local_port)
        return
     */
    return free_port(function(err, local_port) {
      var args, cb_happened, command, kill_if_no_new_activity, kill_if_no_new_output, kill_no_activity_timer, kill_no_output_timer, new_output, r, stderr;
      if (err) {
        opts.cb(err);
        return;
      }
      winston.debug("forward_remote_port_to_local_host: local port " + local_port + " available");
      command = "ssh";
      args = ['-o', 'StrictHostKeyChecking=no', "-p", opts.ssh_port, '-L', local_port + ":localhost:" + opts.remote_port, opts.username + "@" + opts.host, "TERM=vt100 /usr/bin/watch -t -n " + opts.keep_alive_time + " date"];
      r = child_process.spawn(command, args);
      cb_happened = false;
      new_output = false;
      r.stdout.on('data', function(data) {
        address_to_local_port[remote_address] = local_port;
        local_port_to_child_process[local_port] = r;
        new_output = true;
        if (!cb_happened) {
          opts.cb(false, local_port);
          return cb_happened = true;
        }
      });
      stderr = '';
      r.stderr.on('data', function(data) {
        return stderr += data.toString();
      });
      kill_if_no_new_output = function() {
        if (!new_output) {
          winston.debug("Killing ssh port forward " + remote_address + " --> localhost:" + local_port + " due to it not working");
          r.kill("SIGKILL");
        }
        return new_output = false;
      };
      kill_no_output_timer = setInterval(kill_if_no_new_output, 1000 * opts.keep_alive_time);
      kill_if_no_new_activity = function() {
        if (r.activity == null) {
          winston.debug("Killing ssh port forward " + remote_address + " --> localhost:" + local_port + " due to not receiving any data for at least " + opts.activity_time + " seconds.");
          return r.kill("SIGKILL");
        } else {
          return delete r.activity;
        }
      };
      kill_no_activity_timer = setInterval(kill_if_no_new_activity, 1000 * opts.activity_time);
      return r.on('exit', function(code) {
        if (!cb_happened) {
          opts.cb("Problem setting up ssh port forward -- " + stderr);
        }
        delete address_to_local_port[remote_address];
        clearInterval(kill_no_output_timer);
        return clearInterval(kill_no_activity_timer);
      });
    });
  };

  exports.abspath = abspath = function(path) {
    var p;
    if (path.length === 0) {
      return process.env.HOME;
    }
    if (path[0] === '/') {
      return path;
    }
    p = process.env.HOME + '/' + path;
    p = p.replace(/\/\.\//g, '/');
    return p;
  };

  ensure_containing_directory_exists = function(path, cb) {
    var dir;
    path = abspath(path);
    dir = misc.path_split(path).head;
    return fs.exists(dir, function(exists) {
      if (exists) {
        return typeof cb === "function" ? cb() : void 0;
      } else {
        return async.series([
          function(cb) {
            if (dir !== '') {
              return ensure_containing_directory_exists(dir, cb);
            } else {
              return cb();
            }
          }, function(cb) {
            return fs.mkdir(dir, 0x1c0, cb);
          }
        ], function(err) {
          if (err.code === 'EEXIST') {
            return typeof cb === "function" ? cb() : void 0;
          } else {
            return typeof cb === "function" ? cb(err) : void 0;
          }
        });
      }
    });
  };

  exports.ensure_containing_directory_exists = ensure_containing_directory_exists;

  exports.is_file_readonly = function(opts) {
    var readonly;
    opts = defaults(opts, {
      path: required,
      cb: required
    });
    readonly = void 0;
    return execute_code({
      command: 'find',
      args: [opts.path, '-maxdepth', '0', '-writable'],
      err_on_exit: false,
      cb: (function(_this) {
        return function(err, output) {
          if (err) {
            return opts.cb(err);
          } else if (output.stderr || output.exit_code) {
            return opts.cb("no such path '" + opts.path + "'");
          } else {
            readonly = output.stdout.length === 0;
            return opts.cb(void 0, readonly);
          }
        };
      })(this)
    });
  };

  exports.saveSync = function(obj, filename) {
    return fs.writeFileSync(filename, JSON.stringify(obj));
  };

  exports.loadSync = function(filename) {
    return JSON.parse(fs.readFileSync(filename).toString());
  };

}).call(this);
